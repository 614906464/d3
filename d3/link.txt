上传下载文件软件：
Xftp
WinSCP

Lantern 中国

大尺寸：width > 1024px
中尺寸：768px < width < 1024px
小尺寸：width < 768px;

git clone https://github.com/herozhou/vue-framework-wz.git


vue2 项目地址：https://codeday.me/news/20170607/21061.html
https://www.jianshu.com/p/a8a9d8ebd647


45页：https://toutiao.io/s/zloz
订餐：git clone https://github.com/bailicangdu/vue2-elm.git 

好：elementUI
https://github.com/wdlhao/vue2-element-touzi-admin.git

https://github.com/lanux/Vue-Admin

vue2+webpack+axios

vue2:

https://panjiachen.github.io/vue-element-admin/#/dashboard

基于 vue2+vue-router+vuex2+axios+elementUI 做的自动化后台基础模板：
git clone https://gitea.sailengsi.com/product/sls-admin.git  or  git clone https://github.com/sailengsi/sls-admin.git


企业大数据信用服务平台（崇州）
什邡市中小企业服务平台


d3
http://d3.decembercafe.org/




http://www.cnblogs.com/zhouyangla/p/6753673.html


https://www.aliyun.com/?utm_medium=text&utm_source=bdbrand&utm_campaign=bdbrand&utm_content=se_32492

http://www.liangzisj.com/liangzisj/liangzisj/liangzisj.html#page4

https://www.bbdservice.com/index
https://www.163yun.com/?id=baidu&tag=Y_baidu_wyy_000001
http://www.qichacha.com/
https://www.tianyancha.com/

百度图说：
http://tushuo.baidu.com/


图标：
http://fontawesome.dashgame.com/#top

ngHandsontable
https://jsfiddle.net/gscoppino/Lgj51s9h/


数据库软件：
navicat

linux软件：
VMware
VirturlBox
centOS
samba----映射网络地址

Xshell

XX-Net

工具软件：
webStorm

破解方法：http://blog.csdn.net/it_talk/article/details/52448597
Sublime

jquery
zTree

谷歌浏览接口测试：
Postman

BootCDN:   http://www.bootcdn.cn/angular.js/
go环境搭建：http://blog.csdn.net/win_lin/article/details/48265493
linux环境下mysql 命令：http://www.cnblogs.com/xdpxyxy/archive/2012/11/16/2773662.html
视频插件排行：https://www.awesomes.cn/repos/Media/Video
两个数组比较：http://www.jb51.net/article/85771.htm
angular4浏览器支持：https://www.angular.cn/guide/browser-support
css3特效：http://www.17sucai.com/pins/demoshow/19637
文件上传：http://www.abc3210.com/2012/js_09/jquery-uploadify.shtml
视频播放：http://videojs.com/getting-started/
http://www.jianshu.com/p/ebfeb687eb70

查看端口是否在用


ps -aux | grep playout(项目名称）
chai 12014 0.0 0.0 112648
root 28050 0.0 0.1 193324 2776 ? S
root 28051 0.0 0.1 193324 2776 ? RL
sudo kill -9 20580
sudo kill -9 20581

ps -aux | grep 2047


mysql -root -ptest
show databases;
use bravo_playout;
show tables;
select * from videos;


http://192.168.1.230:3000/bravo_dev/playout/pulls/387/files


make
make centos_tools
make ffmpeg
make bts
make bravoencoder

安装
yum install git 
yum remote git 

安装需求
yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel
yum install gcc perl-ExtUtils-MakeMaker

卸载Centos自带的git1.7.1
通过git –version查看系统带的版本，Cento6.5应该自带的是git版本是1.7.1
yum remove git

下载git最新版本
cd /usr/local/webserver
wget https://www.kernel.org/pub/software/scm/git/git-2.7.2.tar.gz
tar xzf git-2.7.2.tar.gz

安装git并添加到环境变量中
cd git-2.7.2
make prefix=/usr/local/git all
make prefix=/usr/local/git install
echo "export PATH=$PATH:/usr/local/git/bin" >> /etc/profile
source /etc/profile

安装数据库: mysql -uroot -ptest < conf/bls.sql
      启动bls: python manage.py runserver 0:2047
      访问bls: http://192.168.1.69:2047


安装数据库: mysql -uroot -ptest < conf/ums.sql
      启动ums: python manage.py runserver 0:8082
      访问ums: http://192.168.1.69:8082

安装数据库: mysql -uroot -ptest < conf/ums.sql
      生成配置文件: cp conf/config_sample.cfg conf/config.cfg 并且修改config.cfg中ums_host为: 192.168.1.69:8082
      启动ums: python manage.py runserver 0:8082
      访问ums: http://192.168.1.69:8082



var students = []; students[students.length] = new Object(); students[students.length] .name = "Lanny"; students[students.length] .age = "25"; students[students.length] .location = "China"; var json = JSON.stringify(students);
str = 999.999.8kkjjhjui88.mp4
str.substring(str.lastIndexOf(".")+1)

可以把本地的device和自己远程的device分支删掉    删本地（git branch -d xxxx）删远程（git push origin —delete xxx）


http://vitalets.github.io/angular-xeditable/#text-simple
http://angular-ui-tree.github.io/angular-ui-tree/#/basic-example
表单验证：http://www.cnblogs.com/rohelm/p/4033513.html
ES6: http://es6.ruanyifeng.com/#docs/intro

radio 样式美化  https://fatesinger.com/74438
书写规范：https://github.com/fex-team/styleguide/blob/master/javascript.md?utm_source=caibaojian.com

翻墙：XX-Net-3.1.19.zip
bower ENOENT No bower.json present
bower EINVRES Request to https://registry.bower.io/packages/jquery failed width 403
https://github.com/npm/npm/issues

播放器插件：https://www.awesomes.cn/repos/Media/Video

jwplayer.js下载:   https://pan.baidu.com/s/1kTnzBqn#list/path=%2F
js正则生成：   http://tools.jb51.net/regex/create_reg

https://www.iviewui.com/components/page
angular.js 下载地址：http://www.bootcdn.cn/angular.js/
js高级：https://msdn.microsoft.com/zh-cn/library/b9w25k6f(v=vs.94).aspx

go :http://blog.csdn.net/win_lin/article/details/48265493
http://www.jianshu.com/p/371fe20db80c

http://javascript.ruanyifeng.com/#oop

angular4 浏览器支持：https://www.angular.cn/guide/browser-support
react 中文网：https://reactjs.org.cn/book/reactjs101/doc/Ch01/front-end-introduction.html
CSS3特效：http://www.17sucai.com/pins/demoshow/19637
正则表达式在线生成：http://tools.jb51.net/regex/create_reg


在table中可以输入：http://vitalets.github.io/angular-xeditable/#text-simple
对比软件： Beyond Compare
代码书写规范： https://github.com/fex-team/styleguide/blob/master/javascript.md?utm_source=caibaojian.com
在线测试代码效果：http://jsbin.com/goruyehola/edit?html,output


前端实用网址：http://www.jianshu.com/p/53a7da454057?utm_campaign=haruki&utm_content=note&utm_medium=reader_share&utm_source=qq
一、配色类网站：http://colorhunt.co
https://webgradients.com/
https://color.adobe.com/zh/create/color-wheel
http://www.colorhunter.com/
http://www.bootcss.com/p/websafecolors/
http://www.bootcss.com/p/websafecolors/

二、图标类网站：http://www.iconfont.cn/plus
http://www.easyicon.net/iconsearch/ios/
http://www.thinkcmf.com/font/search.html

三、插件类网站：
http://www.jq22.com/
http://www.htmleaf.com/
http://www.layui.com/
http://www.h-ui.net/index.shtml

四、素材类网站

http://588ku.com/
https://unsplash.com/

五、字体类网站
http://www.youziku.com/onlinefont/index
http://www.psjia.com/pssc/fontxz/list_18_3.html

六、工具类
http://tool.lu/
http://www.xueui.cn/design/online-tools
https://tinypng.com/
http://www.css88.com/

http://caibaojian.com


git 
在linux虚拟机执行命令，生成SSH key
ssh-keygen
查看
cat ~/.ssh/id_rsa.pub
把SSH复制到github



设置git的别名：
git config --global alias.co checkout
git config --global alias.br branch
git config --global alias.ci commit
git config --global alias.st status
设置自己的名字和邮箱，每次提交都有这个信息的
git config --global user.name ""
git config --global user.email YourEmail@bravovcloud.com

fork -----git clone----git remote add bravo

git :http://git.oschina.net/progit


联想超融合管理系统联想AIO-H1000，超融合技术将计算、网络、存储和服务器虚拟化等资源和技术集成到同一套单元设备中，大幅提升了计算能力；同时依托其底层分布式存储，可保障数据灾备，使云计算硬件成本在幅降低，数据更安全、业务更可靠、维护更方便，能为客户提供完整的IT基础设施解决方案。

网盘业务发票抬头请写：天津联想协同科技有限公司
超融合业务发票抬头请填写：天津联想超融合科技有限公司



http://www.bjgjj.gov.cn/wsyw/wscx/gjjcx-login.jsp

公积金


http://www.bjrbj.gov.cn/csibiz/indinfo/login.jsp

社保


html5 github 文章地址：
https://github.com/FrontEndRoad/HTML5-FAQ
https://github.com/b3log/html5
https://github.com/NIeeeeee/html5
https://github.com/yalay/html5
https://github.com/NalvyBoo/HTML5

前端常用网站：http://www.cnblogs.com/sb19871023/p/3894452.html
nodejs中文网站：http://nodejs.cn/api/documentation.html
typescript:https://zhongsp.gitbooks.io
es6:http://es6.ruanyifeng.com/#docs/style
http://www.ecma-international.org/ecma-262/6.0/
css3新特性：http://www.ibm.com/developerworks/cn/web/1202_zhouxiang_css3/

我们把互联网想象成一个邮局：当你想给朋友写信时，首先要把内容写在一张信纸上，然后在信封上写上地址，再把信纸装进信封。
当你把信送到邮局，邮件分拣机会根据邮编和地址来判断你的朋友信在哪里。如果他住在一栋有很多房间的公寓林楼里面，邮局会把信件投递到大楼的前台，然后大楼的工作人员会根据房间号再次进行分拣。
互联网的工作原理和上面的过程很类似。不同的是，现实世界中由街道连接起来的楼房和公寓，在互联网世界中被路由器和网线连接起来的计算机所取代。每一台计算机都有一个唯一的地址，让网络可以定位到它。
多个公寓房间共享同一个街道地址，与此类似，多台计算机也可以共享同一个网络或路由器。比如，在使用星巴克提供的免费Wi-Fi时，多台计算机就会共享同一个公网IP地址。尽管如此，你的计算机依然可以通过路由器分配的内网IP地址被单独访问到，路由器就好比公寓大楼的工作人员，而内网IP地址就好比房间号。
IP是互联网协议(Internet Protocol)的缩写。IP地址是为每个接入到网络中的设备分配的数字标识符。计算机、打印机甚至手机都有自己的IP地址。

HTML5是HTML最新的修订版本，2014年10月由万维网联盟（W3C）完成标准制定。目标是替换1999年所制定的HTML4.01和XHTML1.0标准，以期能在互联网应用迅速发展的时候，使网络标准达到匹配当代的网络需求。广义论及HTML5时，实际指的是包括HTML、CSS、JavaScript在内的一套技术组合。它希望能够减少网页浏览器对于需要插件的丰富性网络应用服务，例如：AdobeFlash、Microsoft Sliverlight与Oracle JavaFX的需求，并且提供更多能有效加强网络应用的标准集。

HTML5添加了许多新的语法特征，其中包括<video>、<audio>、<canvas>元素，同时集成了SVG内容。这些元素是为了更容易的在网页中添加和处理多媒体和图片内容而添加的。其它新的元素如<section>、<article>、<header>、<nav>则是为了丰富文档的数据内容。新的属性的添加也是为了同样的目的。同时也有一些属性和元素被移除掉了。一些元素，像<a>、<cite>和<menu>被修改，重新定义或标准化了。


HTML5提供了一些新的元素和属性，反映典型的现代用法网站。其中有些是技术上类似<div>和<span>标签，但有一定含义，例如<nav>（网站导航块）和<footer>。这种标签将有利于搜索引擎的索引整理、小屏幕视障人士使用。同时为其他浏览要素提供了新的功能，通过一个标准接口，如<audio>和<video>标记。一些过时的HTML4.01标记将取消，其中包括纯粹用作显示效果的标记，如<font>和<center>，因为它们已经被CSS替换。还有一些通过DOM的网络行为。

命令行快捷键：
Ctrl + C：用来终止命令
Tab：打一个命令到一半，自动补全
Ctrl+D：退出当前终端
Ctrl+Z：暂停当前进程，可以使用fg恢复它
Ctrl+L：清屏，使光标移动到第一行

github:Ruan YiFeng  ruanyf  wchaowu  yodfz

https://github.com/wchaowu

linux:

相对路径：cd ../mqueue
绝对路径：cd /var/spool/mail
基本命令：

ls:是list的缩写，显示列表，ls -al 显示所有列表
cd:change directiry缩写，切换目录
pwd:显示目前所在的目录
mkdir:新建一个新的目录
rmdir:删除一个空的目录

cp：复制文件或目录
rm：移除文件或目录
mv：移动文件或目录，或更名

cat：由第一行开始显示文件内容
tac：从最后一行开始显示，可以看出tac是cat的倒写形式
nl：显示的时候，顺便输出行号
more:一页一页地显示文件内容
less：与more类似，但是比more更好的是，它可以往前翻页
head：只看头几行
tail：只看结尾几行
od：以二进制的方式读取文件内容


tomcat介绍：
bin：二进制执行文件。里面最常用的文件是startup.bat，如果是Linux或Mac系统启动文件为startup.sh。
conf：配置目录。里面最核心的文件是server.xm。可以在里面改端口号等。默认端口号是8080，也就是说，此端口号不能被其他应用程序占用。
lib：库文件。tomcat运行时需要的jar包所在的目录。
logs：日志。
temp：临时产生的文件，即缓存。
webapps：web的应用程序。web应用放置到此目录下浏览器可以直接访问。
work：编译以后的class文件。


Spring Boot 入门篇:https：//www.zhihu.com/question/53729800?sort=created
Spring Boot Thymeleaf模板：https://my.oschina.net/kevinair/blog/707620
SpringBoot 学习：http://git.oschina.net/didispace/SpringBoot-Learning


键盘数字对应的ASCII码（keycode码）：http://www.cnblogs.com/jeffqing/archive/2012/06/28/2568911.html
CSS3动画：https://isux.tencent.com/css3/index.html?translate
PDF电子书下载：http://www.voidcn.com/blog/u013830841/article/p-4343019.html
               http://www.java1234.com

深度开源框架：http://www.open-open.com/lib/view/open1421201088078.html#articleHeader12
angualr-material前端框架：https://material.angularjs.org/1.1.0/demo/dialog
介绍：https://www.ibm.com/developerworks/cn/web/1506_chengfu_angularmaterial/
        http://www.jianshu.com/p/10c6ccf42e00

 angular-material-icons：       https://klarsys.github.io/angular-material-icons/#

TypeScript:
TypeScript入门：https://github.com/xcatliu/typescript-tutorial/blob/master/introduction/hello-typescript.md
http://tslang.cn/docs/tutorial.html
http://babeljs.cn/docs/setup/
https://material.angular.io/
http://vuejs.org/v2/guide/single-file-components.html
https://github.com/ModuleLoader/es-module-loader
https://ant.design/

北京市生育系统：
http://syz.bjchfp.gov.cn/syfwz/index.html

微服务好处：http://blog.csdn.net/lee_sire/article/details/52131183

更新文件
npm update -save 

鼠标健盘对应的keycode
http://www.cnblogs.com/jeffqing/archive/2012/06/28/2568911.html

特效网:
http://www.5iweb.com.cn/
http://blog.csdn.net/zhwxl_zyx/article/details/50457434

bootstrap:前端分页
http://bootstrap-table.wenzhixin.net.cn/

webstorm下载：
https://confluence.jetbrains.com/display/WI/WebStorm+EAP

字体:fonticon
http://fontawesome.io/examples/
http://www.akuziti.com/

highcharts：http://www.highcharts.com/demo

TypeScript：https://tslang.cn/docs/handbook/tsconfig-json.html

国外一些网站logo
http://www.digitaling.com/articles/24220.html
https://worldvectorlogo.com/
http://logospire.com/

10部程序员看的影片
http://www.runoob.com/w3cnote/10-programmer-documentary.html

韩顺平html+css+js:https://pan.baidu.com/share/link?shareid=1564957672&uk=2671529647#list/path=%2F
http://www.java1234.com/a/javaziliao/webbase/2013/0722/475.html

http://yun.baidu.com/s/1hqzHgUS#list/path=%2F

js网站：百度传课：http://www.chuanke.com/course/_javascript_____.html?statistics_channel_id=1699&statistics_uid=13
js秘密花园：
https://bonsaiden.github.io/JavaScript-Garden/zh/

大学生自学网：http://v.dxsbb.com/jisuanji/465/
51学院：http://edu.51cto.com/
我爱自学网：http://www.52zxw.com/
教程之家：http://www.jczhijia.com/List2/code/40/sp.html
妙味：http://www.miaov.com/
智能社：http://www.zhinengshe.com/?utm_source=baidu&utm_medium=cpc&utm_term=%E6%99%BA%E8%83%BD%E7%A4%BE&utm_content=%E6%99%BA%E8%83%BD%E7%A4%BE-%E5%85%B6%E4%BB%96&utm_campaign=PC-%E5%93%81%E7%89%8C%E8%AF%8D&src=Baidu&medium=PPC&Network=1&kw=47946527042&ad=11904384180&mt=1&ap=cl1&ag_kwid=16448-2-ed0334e94d61e44f.d0dcea7c4a6e6174#B_vid=11299209765865737768
http://www.520it.com/
http://ishare.iask.sina.com.cn/f/15124967.html

测试css特性的支持情况：http://caniuse.com
动态测试各个特性:www.modernizr.com
less库：http://lesscss.org
css框架：www.blueprint.org
lifehacker.com207542263
http://lifehacker.com/5744113/learn-to-code-the-full-beginners-guide

sass:  http://hao.jser.com/archive/2507/
http://www.sasschina.com/guide/

git : https://msysgit.github.io/
AngularJS : http://www.ngnice.com/
278252889 二群：305739270 三：207542263 四:454120058
200242234

根据规定，北京医保规定的A类定点医院、定点专科医院、定点中医医院，为北京市参统人员的共同定点医疗机构，无须选择，参统人员可直接到上述医疗机构就医。这些医院包括：1、首都医科大学附属北京同仁医院；2、首都医科大学宣武医院；3、首都医科大学附属北京友谊医院；4、北京大学第一医院；5、中国医学科学院北京协和医院；6、北京大学人民医院；7、北京大学第三医院；8、北京积水潭医院；9、中国中医科学院广安门医院；10、首都医科大学附属北京朝阳医院；11、中日友好医院；12、北京大学首钢医院；13、首都医科大学附属北京中医医院；14、首都医科大学附属北京天坛医院；15、北京世纪坛医院（北京铁路总医院）



++、--  ：前置或后置自增和自减
+、-、*、/、%   ：加、减、乘、除、求余
<、<=、>、>=   ：小于、小于等于、大于、大于等于
==、!=   ：相等和不想等
===、!==  ：等同和不等同
&&、||   ：逻辑与、逻辑或
=  ：赋值
+ ：字符串连接
?:  ：三元条件语句

break : 用于跳出循环
catch : 语句块，在try语句块执行出错时执行catch语句块。
continue : 跳过循环中的一个迭代。
do...while ：执行一个语句块，在条件语句为true时继续执行该语句块。
for...in : 用于遍历数组或者对象的属性（对数组或者对象的属性进行循环操作）。
return  ：退出函数。


相等和等同运算符需要特别说明一下。相等运算符会尝试将操作数转换为同一类型以便判断是否相等。只要明白其工作方式，这就是一个很方便的特性。

js内置的数组方法：
concat(<otherArray>) ：将数组和参数所指数组的内容合并为一个新数组。可指定多个数组。
join(<separator>) ：将所有数组元素连接为一个字符串。各元素内容用参数指定的字符分隔。
pop() ：把数组当成栈使用，删除并返回数组的最后一个元素
push(<item>) ：把数组当做栈使用，将指定的数据添加到数组中
reverse() : 就地反转数组元素的次序
shift() : 类似pop,但操作的是数组的第一个元素
slice(<start>,<end>) : 返回一个子数组
sort() : 就地对数组元素排序
unshift(<item): 类似push,但新元素被插到数组的开头位置

js window对象的常用方法：
alert():弹出一个警告对话框
confim()：在确认对话中显示指定的字符串
prompt()：弹出一个提示对话框
close()：关闭被引用的窗口
focus() ：将被引用的窗口放在所有打开窗口的前面
open() :打开新浏览器窗口并且显示由URL，或名字引用的文档，并设置创建窗口的属性
resizeBy(offsetx,offsety) : 按照指定的位移量设置窗口的大小
resizeTo(x,y) ：设置窗口的大小

window.open("new.htm","new","height=230,width=250,top=10,left=20");
<body onload="window.setTimeout('window.close()',5000)">

cookie
cookie是网站在访问者硬盘上存储的一些定制的信息段。通过浏览器，网页可以实现对cookie的存储，获取和删除。cookie的目的只有一个，即记录访问者的个体信息。在开始使用cookie前，读者需要知道下面的规则。
浏览器可以存储的总cookie数量不能超过300个，每个服务器不昨超过20个（对于整个服务器，而不仅仅是用户自己的网页或网站）。存储容量也限制在每个cookie 4KB,所以不要试图在一个cookie中存储过多的信息。默认情况下，一个cookie可以在整个浏览器的运行期存在；当用户退出浏览器后，cookie内容也就会消失。为了让一个cookie的持续时间超过这个浏览周期，可以设置失效工期。

<a href="#" onClick="Javascript:window.open('new.htm','width=400','height=200')">
会议记录</a>
 <input type="submit" name="submit" value="关闭" onclick="Mycheck();">
 关闭子窗口刷新父窗口
 function Mycheck(){
    alert("关闭子窗口");
    //刷新父窗口
    window.opener.location.reload();
    //关闭子窗口
    window.close();
 }

 window.showModelessDialog()和window.showModalDialog():

 showModelessDialog()和showModalDialog()方法的区别在于：showModalDialog()打开的网页对话框为模式窗口，置在父窗口上，必须关闭才能访问父窗口；而showModelessDialog()方法打开的对话框是无模式窗口，打开后不必关闭也可以访问父窗口或其他窗口。

get : 获取URL所指定的数据对象
put : 更新URL所指定的数据对象
post : 创建一个新的数据对象，通常使用表单数据值作为数据域
delete : 删除URL所指定的数据对象

前端自动化工作流：
步骤一： win7 64 环境，安装 nodejs ，打开 nodejs.org 下载 nodejs 安装包，并根据提示安装。安装完成后， 打开命令行执行   npm -v   如果正确显示版本号 。输入 sudo npm install npm -g 升级 npm 。
 
步骤二：安装 git （为了后面的 bower 使用），配置环境变量 Path ；
 
步骤三：安装 ruby （编译 compass scss 用），同样配置环境变量；
 
步骤三：全局安装 gulp  ： npm install gulp-cli – g
 
步骤四：全局安装 bower ： npm install bower – g
 
步骤五：如果已经有使用 gulp 的项目则继续；
        否则，建立 gulpfile.js( 自行脑补如何建立 )
 
步骤六：项目文件目录中执行命令 npm install, 安装 nodejs 依赖包到项目中
 
步骤七：执行命令 bower install ，安装前端 js 依赖库到项目中
 
步骤八：执行命令 gem install compass 安装 scss 编译工具 compass
 
步骤九：执行命令 gulp addLibs 添加 gulp 依赖库
 
步骤十：执行命令 gulp compass 编译 scss 文件 
 
步骤十一： npm start 启动 node 服务
 
步骤十二：运行 build.sh/build.bat 编译

directive:
var myModule = angular.module();
myModule.directive('directiveName',function factory(injectables){
    var directiveDefinitionObject = {
        priority:0,
        template:'<div></div>',
        templateUrl:'directive.html',
        replace:false,
        transclude:false,
        restrict:"A",
        scope:false,
        compile:function compile(tElement,tAttrs,transclude){
            return{
                pre:function preLink(scope,iElement,iAttrs,controller){},
                post:function postLink(scope,iElement,iAttrs,controller){}
            }
        }
        link:function postLink(scope,iElement,iAttrs){}
    }
    return directiveDefinitionObject;
})

常见匿名函数：
(function(){
	alert('water');
})();

(function(o){
	alert(o);
})('water');

不常见匿名函数：
~(function(){
	alert('water');
})();

+function(){
	alert('water');
}();

-function(){
	alert('water');
}();

!function(){
	alert('water');
}();

void function(){
	alert('water');
}();

(function(){
	alert('water');
}());

匿名函数的链式调用：
(function(o){
	alert(o);
})('water')('down');


D:\work\webadmin-hh>git status
D:\work\webadmin-hh>git checkout WebContent
D:\work\webadmin-hh>git status
D:\work\webadmin-hh>git log

npm -v
sudo npm install npm -g 升级最新版本

搭建scss环境：
1、npm install -g bower安装bower
2、npm install -g gulp 安装gulp
3、ruby安装ruby(下载软件)
4、gem init
5、gem install compass||gem install scss安装compass

sublime快捷键：
Ctrl+Shift+P：调用命令面板
Ctrl+D：选词
Ctrl+G：跳转到相应的行
Ctrl+J：合并行
Ctrl+L：选择整行
Ctrl+M：光标移动至括号内开始或结束的位置
Ctrl+T：词互换
Ctrl+U：软撤销
Ctrl+P：查找当前项目中的文件和快速搜索
Ctrl+K：Backspace从光标处删除至行首
Ctrl+KB：开启/关闭侧边栏
Ctrl+KK：从光标处删除至行尾
Ctrl+KT：折叠属性
Ctrl+KU：改为大写
Ctrl+KL：改为小写
Ctrl+Enter：插入行后（快速换行）

电子书：http://www.java1234.com/a/javabook/webbase/2014/0305/1739.html


【动画属性】
属性              描述
@keyframes ： 定义一个动画，@keyframes定义的动画名称用来被animation-name所使用。
animation ： 复合属性。检索或设置对象所应用的动画特效。
animation-name ：检索或设置对象所应用的动画名称，必须与规则@keyframes配合使用，因为动
画名称由@keyframes定义。
animation-duration ：检索或设置对象动画的持续时间。
animation-timing-function  ：检索或设置对象动画的过渡类型。
animation-delay  ：检索或设置对象动画的延迟时间。
animation-iteration-count ：检索或设置对象动画的循环次数。
animation-direction ：检索或设置对象动画在循环中是否反向运动。
animation-play-state ：检索或设置对象动画的状态。

【背景属性】
属性             描述
background ：复合属性。设置对象的背景特性。
background-attachment ：设置或检索背景图像是随对象滚动还是固定的。必须先指定background-image属性。
background-color ：设置或检索对象的背景颜色。
background-image ：设置或检索对象的背景图像。
background-position ：设置或检索对象的背景图像位置。必须指定background-image属性。
background-repeat ：设置或检索对象的背景图像如何铺排填充。必须先指定background-image属性。
backgorund-clip ：指定对象的背景图像向外裁剪的区域。
background-origin ：设置或检索对象的背景图像计算background-position时的参考原点（位置）。
background-size ：检索设置对象的背景图像的尺寸大小。

【边框(border)和轮廓(outline)属性】
属性             描述
border ：复合属性。设置对象边框的特性。
border-bottom ：复合属性。设置对象底部边框的特性。
border-bottom-color ：设置或检索对象的底部边框颜色。
border-bottom-style ：设置或检索对象的底部边框样式。
border-bottom-width ：设置或检索对象的底部边框宽度。
border-color ：设置或检索对象的边框颜色。
border-left ：复合属性。设置对象左边边框颜色。
border-left-color : 设置或检索对象的左边边框颜色。
border-left-style : 设置或检索对象的左边边框样式。
border-left-width : 设置或检索对象的左边边框宽度。
border-right ：复合属性。设置对象右边边框的特性。
border-right-color: 设置或检索对象的右边边框颜色。
border-right-style : 设置或检索对象的右边边框样式。
border-right-width : 设置或检索对象的右边边框宽度。
border-style : 设置或检索对象的边框样式。
border-top : 复合属性。设置对象顶部边框的特性。
border-top-color : 设置或检索对象的顶部边框颜色。
border-top-style ：设置或检索对象的顶部边框样式。
border-top-width ：设置或检索对象的顶部边框宽度。
border-width : 设置或检索对象的边框宽度。
outline : 复合属性。设置或检索对象外的线条轮廓。
outline-color : 设置或检索对象外的线条轮廓的颜色。
outline-style : 设置或检索对象外的线条轮廓的样式。
outline-width ：设置或检索对象外的线条轮廓的宽度。
border-bottom-left-radius : 设置或检索对象的左下角边框。提供2个参数，2个参数以空格分隔，每个参数允许设置1个参数值，第1个参数表示水平半径，第2个参数省略，则默认等于第1个参数。
border-bottom-right-radius ：设置或检索对象的右下角圆角边框。
border-image : 设置或检索对象的边框样式使用图像来填充。
border-image-outset ：规定边框图像超过边框的量。
border-image-repeat ：规定图像边框是否应该被重复(repeat)，拉伸(stretched)或铺满(rounded)。
border-image-slice ：规定图像边框的向内偏移。
border-image-source ：规定要使用的图像，代替border-style属性中设置的边框样式。
border-image-width ：规定图像边框的宽度。
border-radius ：设置或检索对象使用圆角边框。
border-top-left-radius ：定义左上角边框的形态。
border-top-right-radius ：定义右下角边框的形状。
border-decoration-break ：规定行内元素被折行。
box-shadow ：向方框添加一个或多个阴影。

【盒子(box)属性】
属性      描述
overflow-x ：如果内容溢出了元素区域，是否对内容的左/右边缘进行裁剪。
overflow-y ：如果内容溢出了元素区域，是否对内容的上/下边缘进行裁剪。
overflow-style ：规定溢出元素的首选滚动方法。
rotation ：围绕rotation-point属性定义的点对元素进行旋转。
rotation-point ：定义距离上边框边缘的偏移点。

【颜色(color)属性】

属性      描述
padding : 在一个声明中设置所有填充属性。
padding-bottom ：设置元素的底填充。
padding-left ：设置元素的左填充。
padding-right ：设置元素的右填充。
padding-top ：设置元素的顶部填充。

【媒体页面内容属性】

属性         描述
bookmark-label ：指定书签的标签。
bookmark-level ：指定了书签级别。
bookmark-target ：指定了书签链接的目标。
float-offset ：在相反的方向推动浮动元素，他们一直具有浮动。
hyphenate-after : 指定一个断字的单词断字字符后的最少字符数。
hyphenate-before ：指定一个断字的单词断字字符前的最少字符数。
hyphenate-character ：指定了当一个断字发生时，要显示的字符串。
hyphenate-lines ：表示连续断字的行在元素的最大数目。
hyphenate-resource ：外部资源指定一个逗号分隔的列表，可以帮助确定浏览器的断字点。
hyphens ：设置如何分割单词以改善该段的布局。
image-resolution ：指定了正确的图像分辨率。
marks ：将crop and/or cross标志添加到文档。

【尺寸(dimension)属性】
属性       描述
height ：设置元素的高度。
max-height ：设置元素的最大高度。
max-width ：设置元素的最大宽度。
min-height ：设置元素的最小高度。
min-width ：设置元素的最小宽度。
width ：设置元素的宽度。

【弹性盒子模型(flexible box)属性（新）】
flex ：复合属性。设置或检索弹性盒模型对象的子元素如何分配空间。
flex-grow ：设置或检索弹性盒的扩展比率。
flex-shrink ：设置或检索弹性盒的收缩比率。
flex-basis ：设置或检索弹性盒伸缩基准值。
flex-flow ：复合属性。设置或检索弹性盒模型对象的子元素排列方式。
flex-direction ：该属性通过定义flex容器的主轴方向来决定felx子项在flex容器中的位置。
flex-wrap ：该属性控制flex容器是单行或者多行，同时横轴的方向决定了新行堆叠的方向。
align-content ：在弹性容器内的各项没有占用交叉轴上所有可用的空间时对齐容器内的各项（垂直）。
align-items : 定义flex子项在flex容器的当前行的侧轴（纵轴）方向上的对齐方式。
align-self :定义flex子项单独在侧轴（纵轴）方向上的对齐方式。
justify-content ：设置或检索弹性盒子元素在主轴（横轴）方向上的对齐方式。
order ：设置或检索弹性盒模型对象的子元素出现的顺序。

【弹性盒子模型(flexible box)属性（旧）】
属性       描述 
box-align : 指定如何对齐一个框的子元素。
box-derection ：指定在哪个方向，显示一个框的子元素。
box-flex ：指定一个框的子元素是否是灵活的或固定的大小。
box-flex-group ：指派灵活的元素到flex组。
box-lines : 每当它在父框的空间运行时，是否指定将再上一个新的行列。
box-ordinal-group ：指定一个框的子元素的显示顺序。
box-orient ：指定一个框的子元素是否在水平或垂直方向应铺设。
box-pack ：指定横向盒在垂直框的水平位置或垂直位置。

【字体(font)属性】
font :在一个声明中设置所有字体属性。
font-family ：规定文本的字体系列。
font-size ：规定文本的字体尺寸。
font-style ：规定文本的字体样式。
font-variant :设置或检索对象中的文本是否为小型的大写字母。
font-weight ：规定字体的粗细。
@font-face ：一个规则，允许网站下载并使用其他超过"Web-safe"字体的字体。
font-size-adjust : 为元素规定aspect值。
font-stretch ：收缩或拉伸当前的字体系列。

【内容生成属性(generated content properties)】
属性    说明
content ：与:before以及:after伪元素配合使用，来插入生成内容。
counter-increment ：递增或递减一个或多个计数器。
counter-reset ：创建或重复一个或多个计数器。
guotes : 设置嵌套引用的引号类型。
crop ：允许replaced元素只是作为一个对象代替整个对象的矩形区域。
move-to ：Causes an element to be removed from the flow and reinserted at a later point in the document.
page-policy ：判定基于页面的给定元素的适用于计数器的字符串值。

【网络(grid)属性】
属性   说明
grid-columns : 指定在网格中每列的宽度。
grid-rows ：指定在网格中每列的高度。
【超链接(hyperlink)属性】
属性     说明
target   ：简写属性设置target-name,target-new,和target-position属性。
target-name : 指定在何处打开链接（目标位置）。
target-new ：指定是否有新的目标链接打开一个新窗口或在现有窗口打开新标签。
target-position ：指定应该放置新的目标链接的位置。
【线框(linebox)属性】
属性         说明
alignment-adjust ：允许更精确的元素的对齐方式。
alignment-baseline ：其父级指定的内联级别的元素如何对齐。
baseline-shift ：允许重新定位相对于dominant-baseline的dominant-baseline。
dominant-baseline ：指定scaled-baseline-table。
drop-initial-after-adjust ：设置下拉的主要连接点的初始对齐点。
drop-initial-after-align ：校准行内的初始行的设置就是具有字母的框使用初级连接点。
drop-initial-before-adjust ：设置下拉的辅助连接点的初始对齐点。
drop-initial-before-align ：校准行内的初始行的设置就是具有字母的框使用辅助连接点。
drop-initial-size ：控制局部的首字母下沉。
drop-initial-value ：激活一个下拉式的初步效果。
drop-box-align : 设置一个多行的内联块内的行具有前一个和后一个内联元素的对齐。
line-staching ：一个速记设置line-staching-strategy,line-staching-ruby,和line-staching-shift属性。
line-staching-ruby ：设置包含ruby注释元素的行对于块元素的堆叠方法。
line-staching-shift ：设置base-shift行中块元素包含元素的堆叠方法。
line-staching-strategy :设置内部包含块元素的堆叠线框的堆叠方法。
text-height：行内框的文本内容区域设置block-progression维数。

【列表(list)属性】
属性         说明
list-style : 在一个声明中设置所有的列表属性。
list-style-image ：将图像设置为列表项标记。
list-style-position ：设置列表项标记的放置位置。
list-style-type ：设置列表项标记的类型。

【字幕(marquee)属性】
属性     说明
marquee-direction ：设置内容移动的方向。
marquee-play-count ：设置内容移动多少次。
marquee-speed ：设置内容滚动的速度有多快。
marquee-style ：设置内容移动的样式。

【多列(multi-column)属性】
属性       说明
column-count : 指定元素应该分为的列数。
column-fill : 指定如何填充列。
column-gap ：指定列之间的差距。
column-rule : 对于设置所有column-rule-*属性的简写属性。
column-rule-color : 指定列之间的颜色规则。





【angular.js指令】
ng-app ：定义应用程序的根元素。
ng-bind ：绑定HTML元素到应用程序数据。
ng-bind-html ：绑定HTML元素的innerHTML到应用程序数据，并移除HTML字符串中危险字符。
ng-bind-template ：规定要使用模板替换的文本内容。
ng-blur ：规定blur事件的行为。
ng-change ：规定在内容改变时要执行的表达式。
ng-checked ：规定元素是否被选中。
ng-class : 指定HTML元素使用的css类。为某个元素设置class属性。
ng-class-even ：类似ng-class，但只在偶数行起作用。
ng-class-odd ：类似ng-class，但只在奇数行起作用。
ng-click ：定义元素被点击时的行为。
ng-cloak ：在应用正要加载时防止其闪烁。
ng-controller ：定义应用的控制器对象。
ng-copy ：规定拷贝事件的行为。
ng-csp ：修改内容的安全策略。
ng-cut ：规定剪切事件的行为。
ng-dblckick ：规定双击事件的行为。
ng-disabled : 规定一个元素是否被禁用。
ng-focus ：规定聚焦事件的行为。
ng-form ：指定HTML表单继承控制器表单。
ng-hide ：隐藏或显示HTML元素。
ng-href ：为the <a> 元素指定链接。
ng-if ：如果条件为false移除HTML元素。从DOM中添加和移除元素。
ng-include ：在应用中包含HTML文件。
ng-init ：定义应用的初始化值。
ng-jq ：定义应用必须使用到的库，如:jQuery。
ng-keydown 规定按下按键事件的行为。
ng-keypress ：规定按下按键事件的行为。
ng-keyup : 规定松开按键事件的行为。
ng-list ：将文本转换为列表（数组）。
ng-model ：绑定HTML控制器的值到应用数据。
ng-model-options : 规定如何更新模型。
ng-mousedown ：规定按下鼠标键时的行为。
ng-mouseenter ：规定鼠标指针穿过元素时的行为。
ng-mouseleave ：规定鼠标指针离开元素时的行为。
ng-mousemove ：规定鼠标指针在指定的元素中移动时的行为。
ng-mouseover ：规定鼠标指针位于元素上方时的行为。
ng-mouseup ：规定当在元素上松开鼠标按钮时的行为。
ng-non-bindable :规定元素或子元素不能绑定数据。
ng-open : 指定元素的open属性。
ng-options ：在<select>列表中指定<options>
ng-paste ：规定粘贴 事件的行为。
ng-pluralize : 根据本地化规则显示信息。
ng-readonly ：指定元素的readonly属性。
ng-repeat ：定义集合中每项数据的模板。
ng-selected : 指定元素的selected属性。
ng-show ：显示或隐藏HTML元素、在DOM中显示和隐藏元素。
ng-src : 指定<img>元素的src属性。
ng-srcset : 指定<img>元素的srcset 属性。
ng-style : 指定元素的style属性。设置一个或多个CSS属性。
ng-submit : 规定onsubmit事件发生时执行的表达式。
ng-switch ：规定显示或隐藏子元素的条件。
ng-transclude ：规定填充的目标位置。
ng-value : 规定input 元素的值。

【】
$controller ：封装$injector服务封装的实例化控制器
$document ：提供jqLite对象，包括DOM(Document Object Model文档)
$exceptionHandler : 处理应用程序中出现的异常
$filter ：提供过滤器入口
$http : 创建并管理Ajax请求
$injector ：创建AngularJS组件实例
$interpolate ：处理字符吕，包括绑定表达式创建可被用于成成内家
$interval ：提供围绕window.serInterval函数的增强封装。
$location ：提供围绕浏览器location对象的封装。
$log ：提供围绕全局console对象的封装。
$parse : 处理表达式并创建可被用于生成内容的函数。
$provide : 实现许多由Module暴露的方法。
$q : 提供deferred对象/promises。
$resource : 提供对RESTfulAPI动作的支持。
$rootElement : 在DOM中提供根元素的入口、
$rootScope : 提供顶级作用域的入口。
$route : 为基于浏览器URL路径的视图内容改变提供支持。
$routeParams : 提供关于URL路由的信息。
$sanitize : 将危险的HTML字段替换为与之相等的安全显示。
$sce : 为了使它们安全的显示。
$swipe ：识别单击手势。
$timeout : 提供围绕window.setTimeout函数的增强封装。
$window : 提供DOM window 对象的引用。


【AngularJS 事件】
ng-click
ng-dbl-click
ng-mousedown
ng-mouseenter
ng-mouseleave
ng-mousemove
ng-keydown
ng-keyup
ng-keypress
ng-change

【AngularJS全局API】
angular.lowercase()    :将字符串转换为小写。
angular.uppercase()  :将字符串转换为大写。
angular.copy()  :数组或对象深度拷贝。
angular.forEach() : 对象或数组的迭代函数。

表单验证：
ng-empty
ng-not-empty
ng-touched
ng-valid
ng-invalid
ng-dirty
ng-pending
ng-prisitine

【AngularJS 过滤器】
currency : 格式化数字为货币格式。
filter : 从数组项中选择一个子集。
lowercase : 格式化字符串为小写。
orderBy ：根据某个表达式排列数组。
uppercase : 格式化字符串为大写。


【angular.element】
addClass()-为每个匹配的元素添加指定的样式类名
after()-在匹配元素集合中的每个元素后面插入参数所指定的内容，作为其兄弟节点
append()-在每个匹配元素里面的末尾处插入参数内容
attr() - 获取匹配的元素集合中的第一个元素的属性的值
bind() - 为一个元素绑定一个事件处理程序
children() - 获得匹配元素集合中每个元素的子元素，选择器选择性筛选
clone()-创建一个匹配的元素集合的深度拷贝副本
contents()-获得匹配元素集合中每个元素的子元素，包括文字和注释节点
css() - 获取匹配元素集合中的第一个元素的样式属性的值
data()-在匹配元素上存储任意相关数据
detach()-从DOM中去掉所有匹配的元素
empty()-从DOM中移除集合中匹配元素的所有子节点
eq()-减少匹配元素的集合为指定的索引的哪一个元素
find() - 通过一个选择器，jQuery对象，或元素过滤，得到当前匹配的元素集合中每个元素的后代
hasClass()-确定任何一个匹配元素是否有被分配给定的（样式）类
html()-获取集合中第一个匹配元素的HTML内容
next() - 取得匹配的元素集合中每一个元素紧邻的后面同辈元素的元素集合。如果提供一个选择器，那么只有紧跟着的兄弟元素满足选择器时，才会返回此元素
on() - 在选定的元素上绑定一个或多个事件处理函数
off() - 移除一个事件处理函数
one() - 为元素的事件添加处理函数。处理函数在每个元素上每种事件类型最多执行一次
parent() - 取得匹配元素集合中，每个元素的父元素，可以提供一个可选的选择器
prepend()-将参数内容插入到每个匹配元素的前面（元素内部）
prop()-获取匹配的元素集中第一个元素的属性（property）值
ready()-当DOM准备就绪时，指定一个函数来执行
remove()-将匹配元素集合从DOM中删除。（同时移除元素上的事件及 jQuery 数据。）
removeAttr()-为匹配的元素集合中的每个元素中移除一个属性（attribute）
removeClass()-移除集合中每个匹配元素上一个，多个或全部样式
removeData()-在元素上移除绑定的数据
replaceWith()-用提供的内容替换集合中所有匹配的元素并且返回被删除元素的集合
text()-得到匹配元素集合中每个元素的合并文本，包括他们的后代
toggleClass()-在匹配的元素集合中的每个元素上添加或删除一个或多个样式类,取决于这个样式类是否存在或值切换属性。即：如果存在（不存在）就删除（添加）一个类
triggerHandler() -为一个事件执行附加到元素的所有处理程序
unbind() - 从元素上删除一个以前附加事件处理程序
val()-获取匹配的元素集合中第一个元素的当前值
wrap()-在每个匹配的元素外层包上一个html元素


angular.js的一些
http://www.tuicool.com/articles/R3uuqye

angular.forEach()
forEach(obj.iterator)
iterator(value,key,obj)
1.value:对象的属性（数组元素）。
2.key:对象的属性名（数组的索引）。
3.obj:数组（对象）本身。
    angular.forEach(data,function(value,key){
        console.log(value);
    })

angular.copy()
copy(source,destination)
如果只有一个参数（没有指定拷贝的对象），则返回一个拷贝对象
如果指定了destination,则会深拷贝对象复制给destination
如果source是null或者undefined，那么会直接返回source
如果source就是desitination，那么会报错。

angular.module

这个方法大家应该都很熟悉了

module(name, requires)，name为模块名，requires(可选)为依赖的模块，当有依赖的模块数组的时候，表示注册一个模块，没有时为引用一个模块。
angular.module('main',[]);
console.log(angular.module('main'));

angular.element
这个方法是用来操作DOM的，一般在指令里面使用。在引入了jquery的情况下，使用方法和jquery几乎一样，相当于一个语法糖。
var ele = angular.element('h1');
console.log(ele.html());
在没有引入jquery的情况下，使用的其实是jqLite(angular自己封装的类似于jquery的一个东西)，使用方法也类似，只不过不支持一些jquery的选择器。
var ele = angular.element(document.getElementByIagName('h1')[0]);
console.log(ele.html());

angular.bootstrap

这个函数不太常用。如果你不想使用ng-app指令来启动angular应用的话，可以用angular.bootstrap()来启动

angular.element(document).ready(function() {
    angular.bootstrap(document, []);
});

angular.toJson

其实就是调用JSON.stringify()方法将一个对象或数组，格式化为JSON字符串。

angular.fromJSON

就是调用JSON.parse()方法将一个JSON字符串转换为一个对象

angular.extend

extend(destination, src1, src2…)这个方法是用来扩展对象的，destination为要扩展的对象，会将后面的对象的属性全部复制到destination中，不过是浅复制

angular. merge

这个方法和extend方法是一样的，也是用来扩展目标对象的，不过用的是深复制
http://www.jianshu.com/p/b941040e57e3
merge和extend常用于获取存储在服务端的用户设置，然后需要和本地的结合的这一类案例



Javascript基于原型的继承与面向对象中基于类的继承有着微妙的区别

jQuery是一个酷炫的库，它有标准化的跨平台开发，几乎已经成为了现代化web开发的必需品。不过尽管jQuery如此多的优秀特性，它的理念和angularJS并不一致。

angularJS是一个用来建立app的框架，而jQuery则是一个简化"HTML文档操作、事件处理、动画和ajax"的库。这是两者最基本的区别，angularJS致力于程序的体系结构，与HTML页面无关。

DOM操作应该只在指令中完成，但这并不意味着他们只能用jQuery封装。在你使用jQuery之前，你应该总是去想一下这个功能是不是angularJS已经提供了。当指令互相依赖时能够创建强大的工具，这确实很强大。

jQuery是一个库而angularJS是一个框架，使用库是指：你的代码决定什么时候从库中调用一个特定的方法；使用框架则是：你实现了一些回调方法，到了特定的时候框架会去调用这些方法。




所谓个税抵扣房贷利息，简单说来，就是把工资先扣去房贷利息，再来缴税。这样算下来你每个月要扣除的个税就会减少。
个税抵扣房贷是什么意思？

个人所得税抵扣房贷，简单说就是公司财务在核算你本月工资时，除了扣除五险一金外，还会把你所承担的房贷中的利息部分，也一并扣除，最后剩下多少钱，再去计税。

回顾一下当前个人所得税的计算：

★应纳税额=工资薪金所得-五险一金

★缴税=应纳税所得额*税率-速算扣除数

★实发工资=应发工资-五险一金-缴税。

CDUR：适合Angular.js
create,delete,update,retrieve

angular.js框架：http://www.php100.com/html/dujia/2015/0206/8580.html
                http://www.oschina.net/news/60200/bestl-angularjs-tools

$q
Promise:是一种异步处理模式，有很多的实现方式，比如著名的Kris Kwal's Q还有jQuery有Deffered。
以前了解过Ajax的都能体会到回调的痛苦，同步的代码很容易调试，但是异步回调的代码，会让开发者陷入泥潭，无法跟踪，比如：
funA(arg1,arg2,function(){
    funcB(arg1,arg2,function(){
    funcC(arg1,arg2,function(){
    xxxx
    })
    })
})


指令的作用是把我们自定义的语义化标签替换成浏览器能够认识的HTML标签。那好，如果我们自定义的标签内部出现了子标签，应该如何去处理呢？很显然，transclude就是用来处理这种情况的。

在angular中，$scope是一个关键的服务，可以被注入到controller中，注入其他服务却只能是$rootscope。scope是一个概念，是一个类，而$rootscope和被注入到controller中的一个具体的$scope都是一个个具体的对象。$rootscope之所以被称为"root"的原因就是他是所有scope的祖先，$rootscope是在angular启动流程中建立的，而被注入到controller中的$scope则是在视图创建的时候通过父辈的$scope.$new制造出来的，在视图销毁的时候，$scope会被跟着销毁。$scope是链接视图和controller的重要手段，controller则是可以与服务进行链接，将服务提供的功能进行组合，然后丢给$scope，$scope则将这些传递给视图，让它显示给用户。

如果将一个$scope比作一个人的话，那么他的功能有：生育功能($new)，进食功能($watch)，消化功能($digest)，执行功能($apply)，交流功能($on、$emit、$broadcast)，死亡功能($destory)。

在讲$rootscope前，先明确两个概念：工厂函数和构造函数。

1、工厂函数，能够根据传入的参数不同返回同一种性质的对象的函数。

工厂模式是软件工程领域一种广为人知的设计模式，而由于在ECMAScript中无法创建类，因此用函数封装以特定接口创建对象。其实方法非常简单，也就是在函数内创建一个对象，给对象赋予属性及方法再将对象返回即可。

function createBlog(name,url){
    var o = new Object();
    o.name = name;
    o.url = url;
    o.sayUrl = function(){
        alert(this.url);
    }
    return o;
}
var blog1 = createBlog('wuyuchang','http://www.jb');

可以看到工厂模式的实现方法非常简单，解决了创建多个相似对象的问题，但是工厂模式却无从识别对象的类型，因为全部都是Object,不像Date、Array等，因此出现了构造函数模式、

构造函数模式：
ECMAScript中构造函数可以创建特定类型的对象，类似于Array、Date等原生JS的对象。其实现方法如下：
function Blog(name,url){
    this.name = name;
    this.url = url;
    this.alertUrl = function(){
        alert(this.url);
    }
}
var blog = new Blog('hhh','http://www.hhh');

构造函数与工厂函数之间差异：
1、工厂函数需要创建对象，以及必须有返回值，
2、工厂函数针对的都是Object的对象模型，而构造函数可以匹配自定义的对象模型；
    即前者不论创建什么都只有一个xx instanceof Object
    而后者根据自定义名而定类型；
3、构造函数弊端，如果在全局中定义相同的局部变量，容易造成全局污染，因为this.xx如果在局部获取不到，就会去全局中获取；
4、构造函数可以重写，可以在全局中添加新属性和方法Person.prototype = {},但工厂函数只能在局部添加各自适用场合：
    构造函数：适应于大型项目，属性以及方法时常变换的项目；
    工厂函数：适应于小型项目，或者正在制作过程还没有成型的项目。

工厂方法的思路是在一个函数中创建一个对象，然后为这个对象设置相应的属性和方法，最后将这个对象返回。通过函数来封装，以特定的接口创建对象。
    function createPerson(name,age){
        var o = new Object();
        o.name = name;
        o.age = age;
        o.say = function(){
            alert(this.name+','+this.age);
        }
        return o;
    }
    //实例化p1和p2对象
    var p1 = createPerson('Leon',22);
    var p2 = createPerson("Ada",20);
    //调用p1和p2对象的say()方法
    p1.say();
    p2.say();

使用工厂方法虽然有效的解决了类的问题，但是依然存在另外一个问题。我们无法检测对象p1和p2的数据类型。我们使用typeof仅仅只能检测出对象是一个Object类型:
console.info(typeof p1);//Object


由于工厂方法不能确定对象的具体类型，所以人们又提出了一种新的创建JavaScript对象的方法——构造函数方法。在JavaScript中构造函数可以用来创建特定类型的对象，例如Object和Array这些js原生构造函数，在运行时会自动出现在执行环境中。我们也可以自定义构造函数，从而定义自定义类型的属性和方法。

使用构造函数来创建类和基于工厂的方式来创建类的方法相似，最大的区别是函数的名称就是类的名称。通常按照编程规范的约定，类的第一个字母大写。使用构造函数创建类时，在函数内部通过this关键字来完成属性的定义。

//使用构造函数方式来创建Person类
function Person(name,age){
    this.name = name;
    this.age = age;
    this.say = function(){
        console.log(this.name+','+this.age);
    }
}
//通过new 关键字来创建对象
var p1 = new Person("Leon",22);
var p2 = new person("Ada",20);
//调用对象的方法：
p1.say();
p2.say();

使用构造函数的方式很好的解决了检测对象类型的问题，我们可以通过instanceof关键字来判断对象是不是Person类型：
console.info(p1 instanceof Person); //true
console.info(p2 instanceof Person); //true

另外，我们还可以通过constructor关键字来查看对象的构造函数是否是Person类型：
console.info(p1.constructor == Person); //true
console.info(p2.constructor == person); //true


使用构造函数方法给我们所带来的问题是每一个对象中都会存在一个方法的拷贝，如果对象的方法很多的话，就会占用大量的内存空间。

在一些高级的编译型的面向对象编程语言（如java)中，对象的方法是在运行时动态在栈区产生的，它们不会占用内存。而在JavaScript中，使用构造函数方法创建的对象，对象中的每一个方法都是类方法的一个拷贝，如果对象中存在大量的方法，就会占用大量的内存空间。

我们可以将类的方法放到全局变量中来定义，这样可以让类中的方法指向同一个函数。代码如下：
//使用构造函数方法来创建Person类
    function Person(name,age){
        this.name = name;
        this.age = age;
        //此时的类方法是一个全局方法的引用
        this.say = say;
    }

    //将方法设置为全局的方法；
    function say(){
        alert(this.name+','+this.age);
    }

    通过将类的方法设置为全局方法，可以解决对象中的方法占用内存空间的问题，此时，通过构造函数创建的所有对象中的方法都指向同一个全局函数。

    但是如果 将所有的方法都设置为全局函数，这些函数都可以被window调用，此时就破坏了对象的封装性，而且如果某个对象有大量的方法，就会导致代码中有大量的全局函数，这样也不利于我们的开发。

在JavaScript中，每一个函数都有一个prototype（原型）属性，该属性是一个对象，它的作用是使特定类型的所有对象实例可以共享它所包含的属性和方法。

原型是JavaScript中非常特殊的一个对象，当一个函数创建之后，会随之产生一个原型对象，当通过这个函数的构造函数创建了一个具体的对象之后，在这个具体的对象中，就会有一个属性指向原型。

双向数据绑定是 AngularJS 的核心机制之一。当 view 中有任何数据变化时，会更新到 model ，当 model 中数据有变化时，view 也会同步更新，显然，这需要一个监控。

原理就是，Angular 在 scope 模型上设置了一个 监听队列，用来监听数据变化并更新 view 。每次绑定一个东西到 view 上时 AngularJS 就会往 $watch 队列里插入一条 $watch ，用来检测它监视的 model 里是否有变化的东西。当浏览器接收到可以被 angular context 处理的事件时， $digest 循环就会触发，遍历所有的 $watch ，最后更新 dom。


angular.js单元测试：
module.exports = function(config){
    config.set({
        //下面files里的基础目录
        basePath:'../',

        files:[
        'app/bower_components/angular/angular.js',
        'app/bower_components/angular-route/angular-route.js',
        'app/bower_components/angular-mocks/angular-mocks.js',
        'app/js/**/x.js',
        'test/unit/**/*.js'
        ],
        //是否自动监听上面文件的改变自动运行测试
        autoWatch:true,
        //应用的测试框架
        frameworks:['jasmine'],
        //用什么环境测试代码，这里是chrome
        browsers:['Chrome'],
        //用到的插件，比如chrome浏览器与jasmine插件
        plugins:[
            'karma-chrome-launcher',
            'karma-firefox-launcher',
            'karma-jasmine',
            'karma-junit-reporter'
        ],
        //测试内家的输出以及文件的信息
        reporters:['progress','junit'],
        //设置输出测试内容文件的信息
        junitReporter:{
            outputFile:'test_out/unit.xml',
            suite:'unit'
        }
    });
};



网站：http://firli120759.faisco.cn/
        http://m.firli120759.faisco.cn/manage/mobiDesign.jsp


响应式模板：模板之家：http://www.cssmoban.com/

在线测试工具：http://browsershots.org/

http://www.logphp.com/html/%E6%89%8B%E6%9C%BAapp%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/8.html

搜索引擎优化（英语：search engine optimization,缩写SEO）,是一种通过了解搜索引擎的动作规则来调整网站，以及提高目的网站在有关搜索引擎内排名的方式。由于不少研究发现，搜索引擎的用户往往只会留意搜索结果最前面的几个条目，所以不少网站都希望通过各种形式来影响搜索引擎的排序，让自己的网站可以有优秀的搜索排名。当中尤以各种依靠广告维生的网站为甚。
所谓“针对搜索引擎作最优化的处理”，是指为了要让网站更容易被搜索引擎接受。搜索引擎会将网站彼此间的内容做一些相关性的数据比对，然后再由浏览器将这些内容以最快速且接近最完整的方式，呈现给搜索者。搜索引擎优化就是通过搜索引擎的规则进行优化，为用户打造更好的用户体验，最终的目的就是做好用户体验。
对于任何一个网站来说，要想在网站推广中获取成功，搜索引擎优化都是至为关键的一项任务。同时，随着搜索引擎不断变换它们的搜索排名算法规则，每次算法上的改变都会让一些排名很好的网站在一夜之间名落孙山，而失去排名的直接后果就是失去了网站固有的可观访问流量。所以每次搜索引擎算演法的改变都会在网站之中引起不小的骚动和焦虑。可以说，搜索引擎优化是一个愈来愈复杂的任务。

SEO是由英文Search Engine Optimization缩写而来，中文译为“搜索引擎优化”。SEO是指通过站内优化（比如网站结构调整、网站内容建设、网站代码优化等）以及站外优化（比如网站站外推广、网站品牌建设等），使网站满足搜索引擎收录排名需求，在搜索引擎中提高关键词排名，从而吸引精准用户进入网站，获得免费流量，产生直接销售或品牌推广。


关于SEO，严谨的定义如下：SEO是指在了解搜索引擎自然排名机制的基础之上，对网站进行内部及外部的调整优化，改进网站在搜索引擎中关键词的自然排名，获得更多的展现量，吸引更多目标客户点击访问网站，从而达到互联网营销及品牌建设的目标。搜索引擎检索原则是不断更改的，检索原则的更改会直接导致网站关键字在搜索引擎上排名的变化，所以搜索引擎优化并非一劳永逸。

在意识层面，站长对SEO可以形象理解为：当用户进入搜索引擎，就好像进入了一个偌大的图书馆。那么在这个图书馆里面有非常多的分类，分类分成大分类（可以理解为书架）小分类（可以理解为书架上面的格子）以及具体到最小的分类（书的内容）——长尾关键词。

在图书馆里面每天都在增加新的内容，那么一个新的网站出现就等于一个分类里面的一本新书出现。那么书里面的书名以及顺序就相对应到网站的title以及description。可是如果“别人”（可以指搜索引擎）进入图书馆泡馆的时候发现这本书，虽然是这个分类或者一个系列里的书，但是这本书名跟之前的一些书名完全一样，那么肯定会让读者误会站长们是在抄袭别人的书，所以原创将影响到站长们的排名。那么虽然站长们的网站是新的，但是其实在刚开始站长们就不可能有一个好的排名了。这严复影响到日后的优化。

网站优化能够帮助站长们提高网页的综合指数，如果站长们的链接已经得到提升，继续保持高质量反向链接数的增加和内容的维护，站长们的左侧排名会继续保持或提高。除非后期应用了作弊的方式而受到惩罚或停止后期的维护。而竞价广告如果停止了，网站链接也就会即刻消失。

一个事件的真正面目被越来越多的人所误解导致模糊认识，那么人们还能看到它真正的面目吗？不能
故SEO需要创新，必须首先要推翻之前的“陈规陋习”，附上时代赋予SEO的特征，并在理论上不断完善。

搜索引擎优化的主要工作是通过了解各类搜索引擎如何抓取互联网页面、如何进行索引以及如何 确定其对某一特定关键词的搜索结果排名等技术，现在网上关于这方面的教程有很多，但很多都是过时的，因为互联网是在不断的变化的，来对网页内容进行相关的优化，使其符合用户浏览习惯，在不损害用户体验的情况下提高搜索引擎排名，从而提高网站访问量，最终提升网站的销售能力或宣传能力的技术。

为了说明什么是网站对搜索引擎优化，站长搜索引擎不优化的网站分为以下特征：
1、网页中大量采用图片或者Flash等富媒体（Rich Media）形式，没有可以检索的文本信息，而SEO最基本的就是文章SEO和图片SEO；
2、网页没有标题，或者标题中没有包含有效的关键词；
3、网页正文中有效关键词比较少（最好自然而重点分布，不需要特别的堆砌关键词）；
4、网站导航系统让搜索引擎“看不懂”；
5、大量动态网页影响搜索引擎检索；
6、没有其他被搜索引擎已经收录的网站提供的链接；
7、网站中充斥大量欺骗搜索引擎的垃圾信息，如“桥页（也叫门页，过渡页）”、颜色与背景色相同的文字；
8、网站中缺少原创的内容，完全照搬硬抄别人的内容等。



内站优化：
（1）meta标签优化：例如：title,keywords,description等的优化；
（2）内部链接的优化，包括相关性链接（tag标签），锚文本链接，各导航链接，及图片链接；
（3）网站内容更新：每天保持站内的更新（主要是文章的更新等）。
外部优化：
（1）外部链接类别：博客、论坛、B2B、新闻、分类信息、贴吧、问答、百科、社区、空间、微信、微博等相关信息网等尽量保持链接的多样性。
（2）外链组建：每天添加一定数量的外部链接，使关键词排名稳定提升。
（3）友链互换：互一些和你网站相关性比较高，整体质量比较好的网站 交换友情链接，巩固稳定关键词排名。

链接优化：
一、网站结构优化：
1、建立网站地图
只要有可能，最好给网站建一个完整的网站地图sitemap。同时把网站地图的链接放在首页上，使搜索引擎能很方便的发现和抓取所有网页信息。
2、每个网页最多距离首页四次点击就能到达。
3、网站的导航系统最好使用文字链接。
4、网站导航中的链接文字应该准确描述栏目的内容。
5、整站的PR传递和流动。
6、网页的互相链接。

二、搜索引擎如何抓取网页
1、搜索引擎如何爬取。（按什么规则，怎样爬取）
2、物理及链接结构
3、URL静态化
4、绝对路径和相对路径
5、内链的权重分配及网站地图
6、避免蜘蛛陷阱
三、链接结构：
网络结构的第二个结构形式：链接结构也称为逻辑结构，也就是有网站内部链接形成的链接的网络图。
四、关键词选择：
1、使用百度推广助手中关键词工具进行选择适合推广的词；
2、做调查来选取关键词；
3、通过查看统计日志来选取关键词；
4、长尾关键词；
5、将关键词进行多重排列组合；
6、尽量不要使用行业通用词；
7、擅于利用地理位置；
8、确定关键词的价值；
9、长尾词的选择；
10、关键词的时效性；
11、分析竞争对手；
12、有些词是从百度的相关搜索中过来的，而非用户搜索的关键词。


优化步骤：

SEO技术并不是简单的几个建议，而是一项需要足够耐心和细致的脑力劳动。林体上，SEO优化主要分8小步：

1、关键词分析（也叫关键词定位）
这是进行SEO优化最重要的一环，关键词分析包括：关键词关注量分析、竞争对手分析、关键词与网站相关性分析、关键词布置、关键词排名预测。

2、网站架构分析：
网站结构符合搜索引擎的爬虫喜好则有利于SEO优化。网站架构分析包括，剔除网站架构不良设计、实现树状目录结构、网站导航与链接优化。

3、网站目录和页面优化
SEO不止是让网站首页在搜索引擎有好的排名，更重要的是让网站的每个页面都带来流量。

4、内容发布和链接布置
搜索引擎喜欢有规律的网站内容更新，所以合理安排网站内容发布日程是SEO优化的重要技巧之一。链接布置则把整个网站有机地串联起来，让搜索引擎明白每个网页的重要性和关键词，实时的参考是第一点的关键词布置。友情链接战役也是这个时候展开。

5、与搜索引擎对话
向各大搜索引擎登陆入口提交尚未收录站点。在搜索引擎看SEO的效果，通过site：站长们的域名，知道站点的收录和更新情况。通过domain：站长们的域名或者link：站长们的域名，知道站点的反向链接情况。更好的实现与搜索引擎对话，建议采用Google网站管理员工具。

6、建立网站地图SiteMap
根据自己的网站结构，制作网站地图，让站长们的网站对搜索引擎更加友好化。让搜索引擎通过SiteMap就可以访问整个站点上的所有网页和栏目。
最好有两套siteMap，一套方便客户快速查找站点信息（html格式），另一套方便搜索引擎得知网站的更新频率、更新时间、页面权重(xml格式)。所建立的sitemap要和站长们网站的实际情况相符合。

7、高质量的友情链接
建立高质量的友情链接，对于SEO优化来说，可以提高网站PR值以及网站的更新率，都是非常关键性的问题。

8、网站流量分析
网站流量分析从SEO结果上指导下一步的SEO策略，同时对网站的用户体验优化也有指导意义。流量分析工具，建议采用分析工具Google Analytics分析工具和百度统计分析工具。

以上8步贵在坚持，

执行难度：
【SEO各种执行方式难度】难易度排名：1、外链建设；2、内容制作；3、撰写博客；4、社会化整合；5、SEO着陆页；6、URL结构；7、竞争对手调研；8、XML网站地图；9、内部链接；11、title标记；12、meat标记。

SEO策略几个常见现象
一、沙盒
什么是沙盒？沙盒的意思是通常指新网站在前期很难在Google有好的排名，一般时间限制在6个月左右。为什么进入沙盒？一般进入沙盒的原因是网站突然增加了大量的外部链接。

二、炸弹
什么是炸弹？炸弹的意思是通过建立大量的外部链接，锚文本（链接文字）全部为关键字，致使网站强行上升排名。为什么会存在炸弹？因为搜索引擎算法问题，林量的锚文本让引擎误认为某个网站是最符合搜索请求的页面，对于新站来说，定时定量的添加错文本比一次性大量的添加锚文本更能增加网站的权重。

三、幽灵
什么是幽灵？幽灵指的是新站排名不稳定，忽高忽低的现象。为什么会出现幽灵？这个主要是因为搜索引擎防止作弊造成的。还有一个因素就是网站的权重问题。

四、连坐
什么是连坐？连坐是古代一咱刑法，在这里指的是被同服务器或IP地址的其他网站牵连，同样也是搜索引擎防止作弊，为了避免链接工厂的泛滥。

五、金三角
金三角指的是Google抓取关键字重点位置一般分布在页面左上，呈三角形。

六、快照回档
快照回档是指百度的快照被退回到之前日期的快照。
形成原因：主机空间不稳定，网站首页的改动，友链链接异常，百度算法的调整，优化过度，使用SEO作弊手法。
解决办法：
稳定的维护跟更新站内折文章以及站外链及友情链接排查及时更新调整！

效果：
1、让更多的用户更快的找到他想找的东西
2、可以让相关关键词排名靠前，满足用户需求
3、让有需求的人首先找到站长们
4、提供搜索结果的自然排名，增加可信度
5、让站长们的网站排名自然靠前，增加网站浏览量，促进网站宣传和业务发展
6、更加方便不懂网络或者知之甚少的人寻找到需要的网络知识
7、为企业节约网络营销费用
8、为网站提供生态式的自我营销解决方案

策略：
seo的策略主要包括关键词优化、对网站结构和SEO整站优化吧内容的优化、注意内链和外链的优化
1、关键词的优化策略
关键词是搜索引擎优化的核心。关键词的选择对于网站在搜索引擎中排名具有关键作用。对于电子商务网站来说，要求用户能够很容易获取自己想要的信息，而用户一般通过关键词来进行检索，那么为了让搜索引擎读懂电子商务网站的信息，站长需要对关键词做如下设置：
第一：用组织名称和服务内容名称命名。
第二：关键词中不仅体现能够提供的服务。还要包括产口或者服务能够解决的问题。
第三：要将季节的变化考虑进去。
第四：要把拼写错误和方言俚语考虑进去。
第五：要描述产品和服务的地理位置。对于家政、鲜花礼品、婚庆服务、网站建设尤为重要。
第六：要考虑突发性事件。比如地震，雪灾等。对于“医药”等关键词特别敏感。
第七：要考虑突出节目等等。

2、对网站结构和内容的优化策略：
优化网站主要包括：网站结构优化、网站标签优化、网站页面优化、为的是让搜索引擎更容易搜索站长们的网站并且关注站长们想排名靠前的关键词。

3、注重内链和外链的优化策略
超链接将分散的网络连成一个整体，对于搜索引擎来说，一个网页被链接的次数和链接入网页的质量是体现网页重要性的一个非常重要的指标。

作用：
1、扩张资本规模
2、优化企业账务结构
3、通过SEO进行资产重组
4、调整产品结构，促进产业升级
5、品牌保护
6、推广（主要作用）
7、为企业节约网络营销费用

SEO白帽
SEO白帽是一种公正的手法，是使用符合主流搜索引擎发行方针规定的SEO优化方法。一直被业内认为是最佳的SEO手法，它是在避免一切风险也避免了与搜索引擎发行方针发生任何的冲突，它也是SEOer从业者的最高职业道德标准。因为搜索引擎是以文本为中心，许多有助于网页亲和力的同样便利于搜索引擎优化。这些方法包括优化图形内容、包括ALT属性、和增加文本说明。甚至Flash动画可于设计该页时包括替代性内容，这本来用来给访客无法阅读Flash的环境用的，来帮助优化。

这里是一些搜索引擎认为适当的方法：
（1）在每页使用一个短、独特和相关的标题。
（2）编辑网页，用与该页的主题。有关的具体术语替换隐晦的字眼。这有助于该站诉求的观众群，在搜索引擎上搜索而被正确导引至该站。
（3）在该站点增加相当数量的原创内容。
（4）使用合理大小、准确描述的汇标，而非只能通过java、javaScript或Adobe Flash应用程序访问。这可通过使用一个专属列出该站所有内容的网页达成（网站地图）
（5）通过自然方式开发链结：Google不花功夫在这有点混淆不清的指南上。写封电子邮件给网站员，告诉他：您刚刚贴了一篇挺好的文章，并且请求链接，这咱做法很可能为搜索引擎所认可。
（6）参与其他网站的网络集团（译按：web ring指的是有相同主题的结盟站群）——只要其它网站是独立的、分享同样题目和可比较的质量。

思路：
1、网页title的优化
2、关键词的选取
3、关键词（keywords）优化
4、元标签及网页描述的优化
5、网站结构和URL优化
6、SEO中的正则表达式
7、让搜索引擎按您的意图先进
8、网页链接的优化
9、heading标签的优化
10、图片（alt）优化
11、网页减肥<网页的DIV+CSS重构，javascript脚本代码的减肥，网页其他部分的减肥>
12、建立一个利于SEO的网站<博客、论坛、进度空间等等>


优化技巧：

关键词位置、密度、处理

1、URL中出现关键词（英文）
2、网页标题中出现关键词（1-3个）
3、关键词标签中出现关键词（1-3个）
4、描述标签中出现关键词（主关键词重复2次）
5、内容中自然出现关键词
6、内容第一段和最后一段出现关键词
7、H1、H2标签中出现关键词
8、导出链接锚文本中包含关键词
9、图片的文件包含关键词
10、ALT属性中出现关键词
11、关键词密度2-8%
12、对关键词加粗或斜体
13、用TAG标签将关键词聚合到一起

内容质量、更新频率、相关性

1、原创的内容最佳，切忌被多次转载的内容
2、内容独立性，与其他页面至少30%互异
3、1000-2000字，合理分段
4、有规律更新，最好是每天
5、内容围绕页面关键词展开，与整站主题相关
6、具有评论功能，评论中出现关键词

导入链接和锚文本

1、高PR值站点的导入链接
2、内容相关页面的导入链接
3、导入链接锚文本中包含页面关键词
4、锚文本存在于网页内容中
5、锚文本周围出现相关关键词
6、导入链接存在3个月以上
7、改链接所在页面的导出链接少于100个
8、导入链接来自不同的IP地址
9、导入链接自然增加
10、锚文本多样化


SEM:
搜索引擎营销：英文Search Engine Marketing，我们通常简称为“SEM”。就是根据用户使用搜索引擎的方式利用用户检索信息的机会尽可能将营销信息传递给目标用户。简单来说，搜索引擎营销就是基于引擎平台的网络营销，利用人们对搜索引擎的依赖和使用习惯，在人们检索信息的时候将信息传递给目标用户。搜索引擎营销的基本思想是让用户发现信息，并通过点击进入网页，进一步了觖所需要的信息。企业通过搜索引擎付费推广，让用户可以直接与公司客服进行交流、了解，实现交易。

搜索引擎营销的基本思想是让用户发现信息，并通过（搜索引擎）搜索点击进入网站/网页进一步了解他所需要的信息。在介绍搜索引擎策略时，一般认为，搜索引擎优化设计主要目标有2个层次：被搜索引擎收录、在搜索结果中排名靠前。这已经是常识问题，简单来说SEM所做的就是以最小的投入在搜索引擎中获最大的访问量并产生商业价值。多数网络营销人员和专来服务商对搜索引擎的目标设定也基本处于这个水平。但从实际情况来看，仅仅做到被搜索引擎收录并且在搜索结果中排名靠前还很不够，因为取得这样的效果实际上并不一定能增加用户的点击率，更不能保证将访问者转化为顾客或者潜在顾客，因此只能说是搜索引擎营销策略中两个最基本的目标。

SEM的方法包括搜索引擎优化（SEO）、付费排名、精准广告以及付费收录。


xs:(max-width:599px)
gt-xs:(min-width:600px)

sm:(min-width:600px) and (max-width:959px)
gt-sm:(min-width:960px)

md:(min-width:960px) and (max-width:1279px)
gt-md:(min-width:1280px)

lg:(min-width:1280px) and (max-width:1919px)
gt-lg:(min-width:1920px)

xl:(min-width:1920px)

layout:flex
layout-xs:flex-xs width<600px
layout-gt-xs:flex-gt-xs width>=600px

layout-sm:flex-sm 600px<=width<960px
layout-gt-sm:flex-gt-sm width>=960px

layout-md:flex-md 960px<=width<1280px
layout-gt-md:flex-gt-md width>=1280px

layout-lg:flex-lg 1280px<=width<1920px
layout-gt-lg:flex-gt-lg width>=1920/b>px

layout-xl:flex-xl width>=1920px


chrome 去掉记住密码后input框变成黄色：
http://stackoverflow.com/questions/2781549/removing-input-background-colour-for-chrome-autocomplete

input:-webkit-autofill,
input:-webkit-autofill:hover,
input:-webkit-autofill:focus,
input:-webkit-autofill:active {
    transition: background-color 5000s ease-in-out 0s;
}

md-input password显示问题：
https://github.com/angular/material/issues/1376

文本相对长度单位：

em：相对于当前对象内文本的字体尺寸。
ex：相对于字符"x"的高度。通常为字体高度的一半。
ch：数字"0"的宽度。
rem：相对于根元素（即html元素）font-size计算值的位数。

视口相对长度单位：

vw：相对于视口的宽度。视口被均分为100单位的vw。
vh：相对于视口的高度。视口被均分为100单位的vh。
vmax：相对于视口的宽度或高度，总是相对于大的那个。视口的宽度或高度被均分为100单位的vmax。
vmin：相对于视口的宽度或高度，总是相对于小的那个。视口的宽度或高度被均分为100单位的vmin。

绝对长度单位：

cm：厘米
mm：毫米
q：1/4毫米(quarter-millimeters);1q = 0.25mm
in：英寸(inches);1in = 2.54cm
pt：点（points）;1pt = 1/72in
pc：派卡(picas);1pc = 12pt
px：像素(pixels);1px = 1/96in

响应式：
small sm 0-640px   处理绝大多数手机的横竖屏模式
medium md 641px-1024px  平板的横竖屏模式
large lg 1025px +  桌面设备

Tabs（选项卡）
Side Menus(侧栏菜单）
Navigation(导航）
Headers/Footers（页眉页脚）
Content（内容）
Scroll（滚动）
Lists（列表）
Form Inputs（表单）
Slide Box（滑动框）
Modal（模型）
Action Sheet（操作表）
Popup（弹出窗口）
Loading（加载）
Platform（平台）
Gesture（手势）
Backdrop（背景）
Utility（工具）
Tap & Click（触碰和点击）
Keyboard（键盘）

过渡：transition:
transition-property:过渡属性（默认值为all）
transition-duration:过渡持续时间（默认值为0s）
transition-timing-function:过渡函数（默认值为ease函数）
transition-delay:过渡延迟时间（默认值为0s）
http://www.cnblogs.com/xiaohuochai/p/5347930.html

过渡函数：
ease:开始和结束慢，中间快。相当于cubic-bezier(0.25,0.1,0.25,1)
linear:匀速。相当于cubic-bezier(0,0,1,1)
ease-in:开始慢。相当于cublic-bezier(0.42,0,1,1)
ease-out:结束慢。相当于cublic-bezier(0,0,0.58,1)
ease-in-out:和ease类似，但比ease幅度大。相当于cublic-bezier(0.42,0,0.58,1)
step-start:直接位于结束处。相当于steps(1,start)
step-end:位于开始经过时间间隔后结束。相当于steps(1,end)

触发方式：
一般地，过渡transition的触发有三种方式，分别是伪类触发、媒体查询触发和javascript（例如点击，双击）触发。其中常用伪类触发包括：:hover(鼠标悬停时触发)、:focus(获得焦点时触发)、:active(用户单击元素并按住鼠标时触发)等



1、最痛恨的是红米手机，ua返回iphone，需要结合platform判断，但是还不准确，导致需要ios和android区别对待的时候就坑了。
2、是fixed的问题。这个解决办法是尽量不要用，不过ios7及以下才会出现这个问题。某些情况下红米也会有这个问题。（最近刚刚遇到，已经被坑挂了）。
3、如果你想要使用css3的动画，那么一定要变着方式使用3d gpu加速的方式，不要试着left，height，width这样的元素进行变换了，android4.4以下版本卡死你。
4、ios全线点击会有300毫秒延迟，使用fastclick解决。这个插件最良心了。
5、web app像素眼设计会纠结你1px边框问题。解决办法有相应知乎大牛答过。
6、qq浏览，uc浏览以及ios的浏览器，滚动时不会触发scroll事件，但会触发touchmove。当停止滚动后会出发scroll。
7、滚动有iscroll插件，但是还是使用原生的比较好。
8、meta功能要用好，禁止缩放，缩放比例，屏蔽电话号码等功能很实用。（手机回答就不列举了）。
9、如果想要像手机淘宝那样的各个平台看起来展示效果一致，那么就使用rem来做单位。
10、-webkit-tap-highlight-color可以取消点击高亮。
11、localStorage在浏览器开启无痕模式下ios会抛异常，导致js中断。
12、一些情况下对非可点击元素监听click事件，ios下不会触发，css增加cursor:pointer就搞定了。当然想要干脆静止点击就是not-allowed。
13、android4.4以下版本，设置圆角属性需要在直接元素上，向父元素设置圆角并且指定overflow:hidden是不会生效的。

1、做点击跳转，长按删除功能的时候坑比较多：
（1）组合使用touchstart,touchmove,touchend,click事件；
（2）部分机型按到文字会弹出选择，复制的选项，使用 onselectstart="return false;" 禁掉；
-- 之后才知道有很多移动端事件处理库可以用,如 Hammer.JS - Hammer.js
2、1px边框问题，可以延伸到很多知识，如物理像素，CSS像素，viewport, rem等等
再谈mobile web retina 下 1px 边框解决方案
移动前端开发之viewport的深入理解
从网易与淘宝的font-size思考前端设计稿与工作流
3、Hybird开发模式下，页面跳转及返回，因为涉及到H5页面之间，H5与原生页面，需要判定从H5还是从原生跳过来，返回键的处理不同。
还有就是用户进入深层级的页面然后返回，有时候需要特殊处理。
目前还没有很好的解决方案，暂且采用url传参的形式进行区分，做相应的处理；
4、相对于底部绝对定位的按钮被键盘顶起来，用js定高
this.clientHeight = document.documentElement.clientHeight;
$('body').height(this.clientHeight);
5、一定要考虑文字过长的情况，要么溢出隐藏，要么换行不会影响布局。多使用一栏固定，另一栏（或多栏）自适应
6、IOS下和安卓对json对象的遍历顺序相反，如
var obj = {x: 1,y: 2},
    str = '',
    temp = '',
    i = 0;
for(var item in obj){
    temp = i === 0 ? '' : '&';
    i++;
    str += temp + item + '=' + obj[item];
}
console.log(str);

移动端总结：
1、320px屏幕下，把页面根元素html的字体大小设置为50px；
2、鉴于我们拿到的设计图目前是640px宽的基准，这样我们就不用每次自己除以2了，直接在PS中量就好；
3、宽度什么的最好还是用百分比处理；涉及到高度、字体大小之类的则用rem。
eg：
设计稿上，div高度为40px,那么css就是div{height:0.4rem;}

rem布局非常简单，首页你只需在页面引入这段原生js代码就可以了：
(function (doc, win) {
    var docEl = doc.documentElement,
        resizeEvt = 'orientationchange' in window ? 'orientationchange' : 'resize',
        recalc = function () {
            var clientWidth = docEl.clientWidth;
            if (!clientWidth) return;
            if(clientWidth>=640){
                docEl.style.fontSize = '100px';
            }else{
                docEl.style.fontSize = 100 * (clientWidth / 640) + 'px';
            }
        };

    if (!doc.addEventListener) return;
    win.addEventListener(resizeEvt, recalc, false);
    doc.addEventListener('DOMContentLoaded', recalc, false);
})(document, window);

这是rem布局的核心代码，这段代码的大意是：
如果页面的宽度超过了640px，那么页面中的html的font-size恒为100px，否则，页面中的html的font-size的大小为：100*（当前页面宽度/640）

1、为什么是640px？
对于手机屏幕来说，640px的页面宽度是一个安全的最大宽度，保证了移动端页面两边不会留白，注意这里的px是css逻辑像素，与设备的物理像素是有区别的。如iPhone 5使用的是Retina视网膜屏幕，使用2px * 2px的device pixel代表1px *1px 的css pixel，所以设备像素为640*1136px，而它的css逻辑像素数为320*568px。

2、为什么要设置html的font-size？
rem就是根元素（即：html）的字体大小。html中的所有标签样式凡是涉及到尺寸的（如：height,width,padding,margin,font-size。甚至，left,top等）你都可以放心大胆的用rem作单位。
如果你把html的font-size设为20px,前面说过，rem就是html的字体大小，那么1rem=20px。
此时宽60px，高40px的元素样式就这样设置如下：
width:3rem;height:2rem;

rem 和 em 单位是由浏览器基于你的设计中的字体大小计算得到的像素值。
em 单位基于使用他们的元素的字体大小。
rem 单位基于 html 元素的字体大小。
em 单位可能受作保继承父元素字体大小影响。
rem 单位可以从浏览器字体 设置中继承字体大小。

使用em 单位应根据组件的字体大小而不是根元素的字体大小。
在不需要使用 em 单位，并且需要根据浏览器的字体大小设置缩放的情况下使用 rem。
使用 rem 单位，除非你确定需要 em 单位，包括对字体大小。
媒体查询中使用 rem 单位。
不要在多列布局中使用 em 或 rem- 改用%。
不要使用 em 或 rem ，如果缩放会不可避免地导致要打破布局元素。

<meta name="viewport" content="device-width,initial-scale=1.0,maximum=scale=1.0, user-scalable=0" />

手机和chrome同步：chrome://inspect/#devices

width：视口宽度。
height：视口高度。

device-width：宽度等于设备宽度
device-height：高度等于设备高度
initial-scale：初始的缩放比例
minimum-scale：允许用户缩放到的最小比例
maximun-scale：允许用户缩放到的最大比例
user-scalable：用户是否可以手动缩放(no,yes)
<link rel="apple-touch-startup-image" href="startup.png" />设置开始页面图片
<link rel="apple-touch-icon" href="iphon_tetris_icon.png" />在设置书签的时候可以显示好看的图标
<link rel="stylesheet" media="all and (orientation:portrait)" href="portrait.css">肖像模式样式
<link rel="stylesheet" media="all and (orientation:landscape)" href="landscape.css">风景模式样式


目标元素宽度 / 上下文元素宽度 = 百分比宽度

多背景：background:url('../img/1.png'),url('../img/2,png');

<style media="all and (orientation:portrait)" type="text/css">竖屏时使用的样式
<style media="all and (orientation:landscape)" type="text/css">横屏时使用的样式

express：

express除了为HTTP模块提供了更高层的接口外，还实现了许多功能，其中包括：
路由控制
模板解析支持
动态视图
用户会话
CSRF保护
静态文件服务
错误控制器
访问日志
缓存
插件支持

express只是一个轻量级的Web框架，多数功能只是对HTTP协议中常用操作的封装，更多的功能肥冬瘦年插件或者整合其他模块来完成。

响应式布局：
十五大测试工具编辑
1.ProtoFluid 4
ProtoFluid简化了液态布局的开发，能够适应CSS和响应式设计，能够构建出精准、动态的视角。开发者可免费使用ProtoFluid，并且还允许开发者使用其它扩展工具，比如FireBug。
2.Viewport Resizer
Viewport Resizer是一款基于浏览器的测试工具，它能够测试任何网站的响应能力。用户只需把网页拖入书签，然后点击需要测试的网页即可检查页面的屏幕分辨率。此外，Viewport Resizer自带的分辨率尺寸不一定能够满足你的需求，所以，用户还可以自定义添加其它类型的屏幕尺寸。
3.Responsive.IS
用户只需输入要测试的网址，即会根据你所选的设备自动改变网页的大小。
4.Respondr
Respondr是一款轻量级、非常方便小巧的工具，用户只需输入网页的URL，然后选择你所要测试的设备，如iPhone、iPad、桌面浏览器等，即可看到网页在不同平台上的显示效果。
5.Froont
Froont是一款基于Web的设计工具，不需要程序员介入的设计编程工具，为设计师们提供了可视化的在线网页设计环境。
6.Responsivepx
Responsivepx 是一个功能简单、但却很方便实用的测试工具，可以测试网页在不同尺寸的显示器上所呈现的效果。此外，Responsivepx 能让你自行调整要显示的尺寸长宽px值。用户即可在线使用，也可以在本地上对网页进行测试。
7.Responsive
Responsive可以让你看到测试网站在同一个屏幕上显示不同分辨率下的效果，不需要切换到不同的模式。
8.Screenfly
Screenfly是一款免费的测试工具，可以用来测试不同客户端下（不同显示器或者移动设备）网站的显示状况。
9.Review.js
Review.js是一个动态的viewport系统，提供高效的响应式网页浏览选择。它是一个纯JavaScript实现的类库，更少的请求使得它对宽带的要求更少，支持插件式的扩展，并且可以支持自定义窗口改变事件。此外，该系统还提供了‘Opt-In’和‘Opt-Out’响应式设计状态。
10.Responsinator
Responsinator提供了仿真的Web界面来测试你的响应式设计，提供了iPhone，Android，iPad，Kindle及其多种设备上的预览效果，你可以方便地看到需要支持的设备的响应式设计效果图。
11.resizeMyBrowser
resizeMyBrowser是一个响应式网页设计工具，允许你选择需要测试的浏览器尺寸。用户可以在15种不同的预设尺寸中选择或输入自定义的尺寸。
12.Responsive Design Bookmarklet
Responsive Design Bookmarklet是一款响应式设计测试工具，用户需要把网页拖拽到书签上方的书签栏，浏览器即会自动应用。用户可以查看网页在不同设备上的预览效果。
13.Adobe Edge Inspect CC
Adobe Edge可以让你在设备上预览和检查响应式网站。
14.I am mobile
I am mobile可以测试网页在各种不同窗口上的显示效果，并且还会给出一些建议，让你的网站更具移动友好性。
15.Retina Images
Retina Images主要用来测试图片在不同的设备上的显示情况，这样有利于用户在开发出高清晰度的图片。此外，你无需更改任何img标签，并且Retina Images安装也十分方便。

安装模块：install
卸载：uninstall

npm install module
npm uninstall module


Modules   module.exports和exports    暴露文件模块属性
DNS   dns.resolve    Dns域名解析
querystring   querystring.parse   HTTP参数解析
HTTP   http.createServer和server.listen     HTTP服务器创建和启动HTTP服务监听地址
util   util.inherits(constructor,superConstructor)  类继承


1.什么是JavaScript解析引擎？
简单地说，JavaScript解析引擎就是能够“读懂”JavaScript代码，并准确地给出代码运行结果的一段程序。比方说，当你写了 var a = 1+1;这样一段代码，JavaScript引擎做的事情就是看懂（解析）你这段代码，并且将a的值变为2。


linux解压压缩包命令：tar-zxvf + 文件名(tar.gz)

node.js:  http://www.nodebeginner.org/index-zh-cn.html
http://www.java1234.com/a/javabook/

expressjs:http://www.expressjs.com.cn/

express： http://expressjs.jser.us/3x_zh-cn/api.html
node API中文版：http://nodeapi.ucdok.com/#/api/

Node.js：
Node.js相对PHP来说其优点在于能处理高并发请求，并且由于Node.js是事件驱动，因此可以更好地节约服务器内存资源。
Node.js可以单独实现一个server,这也是Node.js一个非常大的优点。

a.同步调用是一种阻塞式调用，一段代码调用另一段代码时，必须等待这段代码执行结束并返回结果后，代码才能继续执行下去。
b.异步调用是一种非阻塞式调用，一段异步代码还未执行完，可以继续下一段代码逻辑，当代码执行完以后，通过回调返回继续执行相应的逻辑，而不耽误其他代码的执行。

模块分为两类：原生模块和文件模块。
原生模块即Node.js API提供的原生模块，原生模块在启动时已经被加载。
文件模块为动态加载模块，需要通过调用 Node.js 的 require 方法来实现加载，加载文件模块的工作主要由原生模块 module 来实现和完成。文件模块加载时必须要指定路径。如果要使用相对路径+"./",例如：("./test.js")

## 需要注意的一点是：Node.js会对原生模块和文件模块都进行缓存，因此在第二次require该模块时，不会有重复开销去加载模块，只肥冬瘦年从缓存中读取相应模块数据即可。

Node.js中明确指出：
在文件模块中，只有exports和module.exports对象是暴露给该外部的属性和方法，才能够通过返回的require对象进行调用，其他方法和属性是无法获取的，因此test对象只能调用test.js文件模块中的exports和module.exports的方法和属性。
学习NPM模块安装；
学习安装配置Node.js的项目框架express模块

NPM
Node Packaged Modules 简称NPM，是Node.js的包管理器，也可以说是Node.js的一个库。Node.js本身提供了一些基本的 API 模块，但这些基本的模块难以满足开发者的需求。例如：开发者可能有多种数据库连接方式，但 Node.js 原生模块没有提供任何 API ，因此，Node.js 需要使用 NPM 来管理开发者自我研发的一些模块，并使其能够用于其他开发者。简单地说，NPM 就是Node.js的包管理器，里面的大部分应用模块，都是开发者提供的，例如：MySQL、jade、wind.js等，开发者可以通过 NPM 提交个人Node.js模块成果，而其他开发者也可使用 NPM 下载这些 NPM 模块包，并将 NPM 模块应用到项目中。
https://npmjs.org/

express：
express是一个 Node.js 的 Web 开源框架，一个非常适合Node.js入门学习的开发者，该框架可以快速搭建Web项目开发的框架。其主要集成了Web的 http 服务器的创建、静态文件管理、服务器 url 请求处理、GET和POST请求分发、Session处理等功能。
http://expressjs.com/

Node.js中的继承：

继承的方式主要是通过 Node.js 的 util 模块 inherits API 来实现继承，将一个构造函数的原型方法继承到另一个构造函数中。constructor构造函数的原型将被设置为使用superConstructor构造函数所创建一个新对象。


模块是程序设计中，为完成某一功能所需的一段程序或子程序；或指能由编译程序、装配程序等处理的独立程序单位；或指大型软件系统的一部分。而在Node.js 中可以理解为完成某一功能所需的程序或子程序，同时也可以将Node.js的一个模块理解为一个"类"，但注意，其本身并非是类，而只是简单意义上的一个对象，该对象拥有多个方法和属性，Node.js的模块也拥有私有成员和仅有成员。



JavaScript语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。那么，为什么JavaScript不能有多个线程呢？这样能提高效率啊？
JavaScript的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？
所以，为了避免复杂性，从一诞生，JavaScript就是单线程，这已经成了这门语言的核心特征，将来也不会改变。
为了利用多核UPU的计算能力，HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。所以，这个新标准没有改变JavaScript单线程的配制。


html5表验证：
自动验证：formnovalidate
最大值和最小值：max/min
根据正则表达式来判断用户输入的正确与否：pattern
如果某个字段是必填项：required
目前 IE 10+、Firefox、Chrome、Opera 支持required属性，Safari 不支持。

外国一些好的网站：http://mediaqueri.es/12/
https://www.ibm.com/developerworks/cn/web/1506_zhangqun_responsiveweb/

前端资源汇总：https://cnodejs.org/topic/56e8c95dcf7763a6045c4ae4

尺寸：http://www.ui001.com/chicun/
手机端按钮：http://ahmedrad.github.io/sliiide/
UI iphone：http://www.ui001.com/chicun/
icons: http://fontawesome.io/icons/

sphinx : http://www.th7.cn/system/win/201501/81743.shtml

Javascript 模块化编程: http://kb.cnblogs.com/page/161717/
js数组： http://yzqc.iteye.com/blog/1484478

一套基于HTML5的网络图组件：http://qunee.com/

jQuery轻量级圆形进度指示器插件: http://www.htmleaf.com/Demo/201502171390.html
各个国家的语言：https://www.sitepoint.com/web-foundations/iso-2-letter-language-codes/
git - 简易指南：http://www.bootcss.com/p/git-guide/
git 命令：http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html

前端网：http://www.w3cfuns.com/
极客学院
慕课网
网易云课堂
前端乱炖
博客园知识库
前端范
MSDN Web
SegmentFault
w3cplus
w3ctech
w3help
jobbole
div.io
v2ex
CSDN
cnblogs
The State of Web Type
Frontend Dev Bookmarks
http://www.w3cfuns.com/
http://www.cnqianduan.com/
http://www.qianduanw.com/

视频学习资料：
Frontend Masters
pluralsight.com
tutsplus.com
lynda.com
treehouse
mijingo
codeschool.com
laracasts
eventedmind.com
egghead.io
codecademy.com
Khan Academy
Tagtree
Udacity

Node.js能做什么？
正如JavaScript为客户端而生，Node.js为网络而生。
1、具有复杂逻辑的网站；
2、基于社交网络的大规模Web应用；
3、Web Socket服务器；
4、TCP/UDP套接字应用程序；
5、命令行工具；
6、交互式终端程序；
7、带有图形用户界面的本地应用程序；
8、单元测试工具；
9、客户端JavaScript编译器。

一、路径分析和文件定位
1、模块标识符分析
a.核心模块，如http、fs、path等。
b.    .或..开始的相对路径文件模块。
c.以/开始的绝对路径文件模块。
d.非路径形式的文件模块，如自定义的connect模块。
核心模块：
核心模块的优先级仅次于缓存加载，它在Node的源代码编译过程中已经编译为二进制代码，
其加载过程最快。


前后端JavaScript分别搁置在HTTP的两端，它们扮演的角色并不同。浏览器端的JavaScript需要经历从同一个服务器端分别发到多个客户端执行，而服务器端JavaScript则是相同的代码需要多次执行。前者的瓶颈在于带宽，后者的瓶颈则在于CPU和内存等资源。前者需要通过网络加载代码，后者从磁盘中加载，两者的加载速度不在一个数量级上。

它的生成方式与JavaScript的原型链或作用域链的查找方式十分类似。在加载的过程中，Node会逐个尝试模块路径中的路径，直到找到目标文件为止。可以看出，当前文件的路径越深，模块查找耗时会越多，这是自定义模块的加载速度是最慢的原因。

模块定义
在模块中，上下文提供require()方法来引入外部模块。对应引入的功能，上下文提供了ecports对象用于导出当前模块的方法或者变量，并且它是惟一导出的出口。在模块中，还存在一个module对象，它代表模块自身，而ecports是module的属性。在Node中，一个文件就是一个模块，将方法挂载在exports对象上作为属性即可定义导出的方式：

Node.js 内建了HTTP服务器支持，也就是说你可以轻而易举地实现一个网站和服务器的组合。这和PHP、Perl不一样，因为在使用PHP的时候，必须先搭建一个Apache之类的HTTP服务器，然后通过 HTTP服务器的模块加载或CGI调用，才能将PHP脚本的执行结果呈现给助用户。而当你使用Node.js时，不用额外搭建一个HTTP服务器，因为Node.js本身就内建了一个。这个服务器不仅可以用来调试代码，而且它本身就可以部署到产品环境，它的性能足以满足要求。

Node.js最大的特点就是异步式I/O(或者非阻塞I/O)与事件紧密结合的编程模式。这种模式与传统的同步式I/O 线性的编程思路有很大的不同，因为控制流很大程度上要靠事件和回调函数来组织，一个逻辑要拆分为若干个单元。

阻塞与线程

什么是阻塞(block)呢？线程在执行中如果遇到磁盘读写或网络通信（统称 I/O操作），通常要耗费较长的时间，这时操作系统会剥夺这个线程的CPU 的控制权，使其暂停执行，同时将资源让给其他的工作线程，这种线程调试方式称为阻塞。当I/O 操作完毕时，操作系统将这个线程的阻塞状态解除，恢复其对CPU的控制权，令其继续执行。这种I/O 模式就是通常的同步式I/O （Synchronous I/O）或阻塞式I/O(Blocking I/O)。
相应地，异步式I/O(Asynchronoud I/O)或非阻塞式I/O(Non-blocking I/O)则针对所有I/O操作不采用阻塞的策略。当线程遇到I/O操作时，不会以阻塞的方式等待I/O操作的完成或数据的返回，而只是将I/O请求发送给操作系统，继续执行下一条语句。当操作系统完成I/O操作时，以事件的形式通知执行I/O操作的线程，线程会在特定时时候处理这个事件。为了处理异步I/O，线程必须有事件循环，不断地检查有没有未处理的事件，依次予以处理。

阻塞模式下，一个线程只能处理一项任务，要想提高吞吐量必须通过多线程。而非阻塞模式下，一个线程永远在执行计算操作，这个线程所使用的CPU核心利用率永远是100%，I/O 以事件的方式通知。在阻塞模式下，多线程往往能提高系统吞吐量，因为一个线程阻塞时还有其他线程在工作，多线程可以让CPU资源不被阻塞中的线程浪费。而在非阻塞模式下，线程不会被I/O 阻塞，永远在利用CUP。多线程带来的好处仅仅是在多核CPU的情况下利用更多的核，而Node.js的单线程也能带来同样的好处。这就是为什么Node.js使用了单线程、非阻塞的事件编程模式。

假设我们有一项工作，可以分为两个计算部分和一个I/O部分，I/O部分占的时间比计算多得多（通常都是这样）。如果我们使用阻塞I/O，那么要想获得高并发就必须开启多个线程。而使用异步式I/O时，单线程即可胜任。

单线程事件驱动的异步式I/O 比传统的多线程阻塞式I/O 究竟好在哪里呢？简而言之，异步式I/O 就是少了多线程的开销。对操作系统来说，创建一个线程的代价是十分昂贵的，需要给它分配内存、列入调试，同时在线程切换的时候还要执行内存换页，CPU的缓存被清空，切换回来的时候还要重新从内存中读取信息，破坏了数据的局部性。

当然，异步式编程的缺点在于不符合人们一般的程序设计思维，容易让控制流变得晦涩难懂，给编码和调试都带来了不小的困难。习惯传统编程模式的开发者在刚刚接触到大规模的异步式应用时往往会无所造从，但慢慢习惯以后会好很多。尽管如此，异步式编程还是较为困难，不过可喜的是现在已经有了不少专门解决异步编程问题的库（如async）

同步式I/O(阻塞式)：

利用多线程提供吞吐量
通过事件片分割和线程调度利用多核CPU
需要由操作系统调度多线程使用多核CPU
难以充分利用CPU资源
内存轨迹大，数据局部性弱
符合线性的编程思维

异步式I/O(非阻塞式)：

单线程即可实现高吞吐量
通过功能划分利用多核CPU
可以将单进程绑定到单核CPU
可以充分利用CPU资源
内存轨迹小，数据局部必强
不符合传统编程思维


Node.js所有的异步I/O 操作有完成时都会发送一个事件到事件队列。事件由EventEmitter对象提供。
Node.js的事件循环机制
Node.js在什么时候会进入事件循环呢？答案是Node.js程序由事件循环形如，到事件循环结束，所有的逻辑都是事件的回调函数，所以Node.js始终在事件循环中，程序入口就是事件循环第一下事件的回调函数。事件的回调函数在执行过程中，可能会发出I/O请求或直接发射(emit)事件，执行完毕后再返回事件循环，事件循环会检查事件队列中有没有未处理的事件，直到程序结束。

模块是Node.js应用程序的基本组成部分，文件和模块是一一对应的。换言之，一个Node.js文件就是一个模块，这个文件可能是JavaScript代码、JSON或者编译过的C/C++扩展。

例如：var http=require('http')，其中http是Node.js的一个核心模块，其内部是用C++实现的，外部用JavaScript封装。我们通过require函数获取了这个模块，然后才能使用其中的对象。

创建及加载模块：
1、创建模块：
在Node.js中，创建一个模块非常简单，刘德一一个文件就是一个模块，我们要关注的问题仅仅在于如何在其他文件中获取这个模块。Node.js提供了exports和require两个对象，其中exports是模块公开的接口，require用于从外部获取一个模块的接口，即所获取模块的exports对象。

包是在模块基础上更深一步的抽象，Node.js的包类似于C/C++的函数库或者Java/.Net的类库。它将某个独立的功能封装起来，用于发布、更新、依赖管理和版本控制。Node.js根据CommonJS规范实现了包机制，开发了npm来解决包的发布和获取需求。

Node.js的包是一个目录，其中包含一个JSON格式的包说明文件package.json。严格符合CommonJS规范的包应该具备以下特征：

1、package.json必须在包的顶层目录下；
2、二进制文件应该在bin下；
3、JavaScript代码应该在lib目录下；
4、文档应该在doc目录下；
5、单元测试应该在test目录下。


ECMAScript对于全局变量的定义：
1、在最外层定义的变量；
2、全局对象的属性；
3、隐式定义的变量（未定义直接赋值的变量）。
当定义一个全局变量时，这个变量同时也会成功全局对象的属性，反之亦然。需要注意的是，在Node.js中你不可能在最外层定义变量，因为所有用户代码都是属于当前模块的，而模块本身不是最外层上下文。


http  ServerRequest的属性
complete：客户端请求是否已经发送完成
httpVersion：HTTP协议版本，通常是1.0或1.1
method：HTTP请求方法，如GET、POST、PUT、DELETE等
url：原始的请求路径，例如：/static/image/x.jpg或/user?name=byvoid
headers：HTTP请求头
trailers：HTTP请求尾（不常见）
connection：当前HTTP连接套接字，为net.Socket的实例
socket：connection属性的别名
client：client属性的别名

HTTP客户端
http模块提供了两个函数http.request和http.get,功能是作为客户端向HTTP服务器发起请求。
1、http.request(options,callback)发起HTTP请求。接受两个参数，option是一个类似关联数组的对象，表示请求的参数，callback是请求的回调函数。option常用的参数如下所示：
a. host：请求网站的域名或IP地址。
b. port：请求网站的端口，默认80。
c. metnod：请求方法，默认是GET。
d. path：请求的相对于根的路径，默认是"/"。QueryString应该包含在其中。例如/search?query=byvoid。
e. headers ：一个关联数组对象，为请求头的内容。
callback 传递一个参数，为http.ClientResponse的实例。
http.request 返回一个http.ClientRequest的实例。


REST风格的路由规则：
1、GET：请求获取指定资源。
2、HEAD：请求指定资源的响应头。
3、POST：向指定资源提交数据。
4、PUT：请求服务器存储一个资源。
5、DELETE：请求服务器删除指定资源。
6、TRACE：回显服务器收到的请求，主要用于测试或诊断。
7、CONNECT：HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。
8、OPTIONS：返回服务器支持的HTTP请求方法。
其中我们经常用到的是GET、POST、PUT和DELETE方法。根据REST设计模式，这4种方法通常分别用于实现以下功能：
1、GET：获取
2、POST：新增
3、PUT：更新
4、DELETE：删除



http://www.2ky.cn/Pri_upfile/txdemo/0811/zDialog/zDialogDemo.html

http://www.w3cplus.com/css/create-css-browers-hacks

http://blog.sina.com.cn/s/blog_48b844dd0102vjm2.html

关于浏览器：
<div id="browsers" class="page-inner" style="display:none">
  <H1>联想超融合虚拟化管理平台目前只支持以下浏览器</H1>
  <ul>
    <li><a href="https://www.google.com/chrome/" target=_blank><span class="icon chrome"></span></a>
    <p>Chrome</p>
    <li><a href="https://www.mozilla.org/en-US/firefox/new/" target=_blank><span class="icon firefox"></span></a>
    <P>Firefox</P>
    <li><a href="https://www.apple.com/safari/" target=_blank><span class="icon safari"></span></a>
    <p>Safari</p>
    <li><a href="http://www.microsoft.com/zh-cn/download/internet-explorer-9-details.aspx" target=_blank><span class="icon ie"></span></a>
    <p>Internet Explorer<br><small>(10.0及以上)</small></p></li></ul>
</div>



js判断手机访问或者PC的几个例子(常用于手机跳转)
http://www.jb51.net/article/76449.htm

https://fortawesome.github.io/Font-Awesome/icons/


http://v2.bootcss.com/base-css.html#forms
http://ui-grid.info/docs/#/tutorial/204_column_resizing
https://fortawesome.github.io/Font-Awesome/icons/
http://ui-grid.info/docs/#/api/ui.grid.class:GridOptions.columnDef
http://bootswatch.com/
http://ui-grid.info/docs/#/api/index
https://angular-ui.github.io/bootstrap/#/modal
https://docs.angularjs.org/api/ng/directive/input
http://www.hubwiz.com/course/
https://fortawesome.github.io/Font-Awesome/icons/
http://bootswatch.com/
bootswatch是一款基于bootstrap的汇集了多种风格的前端UI解决方案

https://angular-ui.github.io/bootstrap/

http://echarts.baidu.com/
http://api.highcharts.com/highcharts#Chart
http://www.hcharts.cn/
http://www.hcharts.cn/（中文）
图表:
http://api.highcharts.com/highcharts#Chart

bootstrap fonticon:
http://fontawesome.io/icons/

angular-material-icons:
https://klarsys.github.io/angular-material-icons/#

字转艺术字：
http://www.akuziti.com/

checklist-model插件：
https://vitalets.github.io/checklist-model/

http://ui-grid.info/docs/#/tutorial/204_column_resizing

document.querySelector('input[name=payMoney]').value

https://github.com/flowjs/flow.js

https://dwqs.gitbooks.io/frontenddevhandbook/content/learning/general-front-end.html

http://pan.baidu.com/s/1c0frhIS

https://github.com/showcases/front-end-javascript-frameworks
成熟框架：
http://www.bootcss.com/p/html5boilerplate/
http://getskeleton.com/
http://www.gumbyframework.com/
http://www.getuikit.net/
http://foundation.zurb.com/

http://docs.ngnice.com/guide/controller

https://cc.lenovo.com/fusionwebtest/mobile/

关于移动端：

https://github.com/hoosin/mobile-web-favorites
<meta content="width=device-width; initial-scale=1.0; maximum-scale=1.0; user-scalable=0" name="viewport" />
<meta content="yes" name="apple-mobile-web-app-capable" />
<meta content="black" name="apple-mobile-web-app-status-bar-style" />
<meta content="telephone=no" name="format-detection" />

阻止旋转屏幕时自动调整字体大小：
html, body, form, fieldset, p, div, h1, h2, h3, h4, h5, h6 {-webkit-text-size-adjust:none;}

伸缩布局盒(Flexbox)：
2009年7月 工作草案 (display: box;)
2011年3月 工作草案 (display: flexbox;)
2011年11月 工作草案 (display: flexbox;)
2012年3月 工作草案 (display: flexbox;)
2012年6月 工作草案 (display: flex;)
2012年9月 候选推荐 (display: flex;)
display:flex;
http://www.w3cplus.com/blog/666.html


这段代码依次加载多个 js 文件。
　　这样的写法有很大的缺点。首先，加载的时候，浏览器会停止网页渲染，加载文件越多，网页失去响应的时间就会越长；其次，由于 js 文件之间存在依赖关系，因此必须严格保证加载顺序（比如上例的1.js 要在2.js 的前面），依赖性最大的模块一定要放到最后加载，当依赖关系很复杂的时候，代码的编写和维护都会变得困难。

require.js的诞生，就是为了解决这两个问题：
（1）实现js文件的异步加载，避免网页失去响应；
（2）管理模块之间的依赖性，便于代码的编写和维护。

require.js
http://kb.cnblogs.com/page/161717/

css书写规范：
http://kb.cnblogs.com/page/125663/
1、不要在ID选择器前使用标签名
　　一般写法：DIV#divBox
　　更好写法：#divBox
　　解释：因为ID选择器是唯一的，加上div反而增加不必要的 CSS 匹配。
　　2、不要在 class 选择器前使用标签名
　　一般写法：span.red
　　更好写法：.red
如果是这样定义的就不要去掉，去掉后就会混淆，不过建议最好不要这样写
　　3、尽量少使用层级关系
　　一般写法：#divBoxp.red{color:red;}
　　更好写法：.red{..}
　　4、使用 class 代替层级关系
　　一般写法：#divBox ul li a{display:block;}
　　更好写法：.block{display:block;}
　　5、在 CSS 渲染效率中 id 和 class 的效率是基本相当的
　　class 会在第一次载入中被缓存，在层叠中会有更加好的效果，在根部元素采用id会具有更加好（id有微妙的速度优势）。

相对单位：
http://kb.cnblogs.com/page/157692/

JavaScript值类型和引用类型有哪些？
(1)值类型：数值、布尔值、null、undefined。
(2)引用类型：对象、数组、函数。
1.字符串的使用：
var s = "Hello,world";
s.charAt(0); //"H"
s.slice(-3); //"rld"
s.replace("H","h"); //"hello,world"
s.toUpperCase(); //"HELLO,WOELD"

数组：http://yzqc.iteye.com/blog/1484478


shift:删除原数组第一项，并返回删除元素的值；如果数组为空则返回undefined 
Javascript代码
var a = [1,2,3,4,5];   
var b = a.shift(); //a:[2,3,4,5] b:1  


unshift:将参数添加到原数组开头，并返回数组的长度 
Javascript代码
var a = [1,2,3,4,5];   
var b = a.unshift(-2,-1); //a:[-2,-1,1,2,3,4,5] b:7   

注:在IE6.0下测试返回值总为undefined，FF2.0下测试返回值为7，所以这个方法的返回值不可靠，需要用返回值时可用splice代替本方法来使用。 

pop:删除原数组最后一项，并返回删除元素的值；如果数组为空则返回undefined 
Javascript代码
var a = [1,2,3,4,5];   
var b = a.pop(); //a:[1,2,3,4] b:5  


push:将参数添加到原数组末尾，并返回数组的长度 
Javascript代码
var a = [1,2,3,4,5];   
var b = a.push(6,7); //a:[1,2,3,4,5,6,7] b:7  


concat:返回一个新数组，是将参数添加到原数组中构成的 
Javascript代码
var a = [1,2,3,4,5];   
var b = a.concat(6,7); //a:[1,2,3,4,5] b:[1,2,3,4,5,6,7]  


splice(start,deleteCount,val1,val2,...):从start位置开始删除deleteCount项，并从该位置起插入val1,val2,... 
Javascript代码
var a = [1,2,3,4,5];   
var b = a.splice(2,2,7,8,9); //a:[1,2,7,8,9,5] b:[3,4]   
var b = a.splice(0,1); //同shift   
a.splice(0,0,-2,-1); var b = a.length; //同unshift   
var b = a.splice(a.length-1,1); //同pop   
a.splice(a.length,0,6,7); var b = a.length; //同push  


reverse:将数组反序 
Javascript代码
var a = [1,2,3,4,5];   
var b = a.reverse(); //a:[5,4,3,2,1] b:[5,4,3,2,1]  


sort(orderfunction):按指定的参数对数组进行排序 
Javascript代码
var a = [1,2,3,4,5];   
var b = a.sort(); //a:[1,2,3,4,5] b:[1,2,3,4,5]  


slice(start,end):返回从原数组中指定开始下标到结束下标之间的项组成的新数组 
Javascript代码
var a = [1,2,3,4,5];   
var b = a.slice(2,5); //a:[1,2,3,4,5] b:[3,4,5]  


join(separator):将数组的元素组起一个字符串，以separator为分隔符，省略的话则用默认用逗号为分隔符 
Javascript代码
var a = [1,2,3,4,5];   
var b = a.join("|"); //a:[1,2,3,4,5] b:"1|2|3|4|5"  




数组是JavaScript提供的一个内部对象，它是一个标准的集合，我们可以添加(push)、删除(shift)里面元素，我们还可以通过for循环遍历里面的元素，那么除了数组我们在JavaScript里还可以有别的集合吗? 

　　由于JavaScript的语言特性，我们可以向通用对象动态添加和删除属性。所以Object也可以看成是JS的一种特殊的集合。下面比较一下Array和Object的特性: 

Javascript代码
　　//Array:  
  
/*新建:*/var ary = new Array(); 或 var ary = [];   
/*增加:*/ary.push(value);   
/*删除:*/delete ary[n];   
/*遍历:*/for ( var i=0 ; i < ary.length ; ++i ) ary[i];  
  
　　//Object:  
  
/*新建:*/var obj = new Object(); 或 var obj = {};   
/*增加:*/obj[key] = value; (key为string)   
/*删除:*/delete obj[key];   
/*遍历:*/for ( var key in obj ) obj[key];  


　　从上面的比较可以看出Object完全可以作为一个集合来使用，在使用Popup窗口创建无限级Web页菜单(3)中我介绍过Eric实现的那个__MenuCache__，它也就是一个模拟的集合对象。 

　　如果我们要在Array中检索出一个指定的值，我们需要遍历整个数组: 


Object的这个特性可以用来高效的检索Unique的字符串集合，遍历Array的时间复杂度是O(n)，而遍历Object的时间复杂度是O(1)。虽然对于10000次集合的for检索代价也就几十ms，可是如果是1000*1000次检索或更多，使用Object的优势一下就体现出来了。在此之前我做了一个mapping，把100个Unique的字符mapping到1000个字符串数组上，耗时25-30s!后来把for遍历改成了Object模拟的集合的成员引用，同样的数据量mapping，耗时仅1.7-2s!!! 

对于集合的遍历效率(从高到低):var value = obj[key]; > for ( ; ; ) > for ( in )。效率最差的就是for( in )了，如果集合过大，尽量不要使用for ( in )遍历。

何为函数，-----凡是名称后带有小括号的都是函数，都具有执行性
何为属性，-----凡是通过点语法向下访问的名称都是属性；（凡是通过点语法向下访问的变量都是属性）
何为语句，-----凡是由一个关键词和一对小括号以及一对大括号拼接组合而成的都是语句；


程序中的循环必须具备3个必须的量；
1.循环的初始；
2.循环的条件；
3.循环的增量；

for(var i=0;i<10;i++){循环体} 实际就是设置循环体到底执行多少遍；

循环的一个常用嵌套格式；循环内部嵌套判断


两种转义符号；
1.转义特殊符号   \
2.换行符号   \n


排他思想；
程序中凡是遇到 只让自己怎么样，而不让其他同类怎么样的这种情况都需要用排他思想； （应用的领域非常多）

排他思想一定分成两步进行，排他思想必然用到for循环；
1.for循环排除所有人；
2.this确立自己；



js的自定义属性没有兼容性问题； html的自定义属性有兼容性问题；


for循环如果存在嵌套关系，那么循环的次数是一个相乘递增的关系；  （只有同级别的for循环才可能执行相同的次数；）

循环精灵i只有在for循环里面可以使用；  循环语句同级别的只要执行的次数相同；那么就可以合并；如果是嵌套级别的一定不能合并；


总结：this指向问题；this只有在事件函数内部的时候 它才能表示用户所控制的那个当前的对象；

原因：只有在因果关系当中才存在用户； （在因果关系中this永远是跟用户有关系的一个量）


#box  ------ 一吨重
.all------一斤重
div-------一克重

touchstart:手指触摸屏幕上的时候触发 

touchmove:手指在屏幕上移动的时候触发 

touchend:手指从屏幕上拿起的时候触发 

touchcancel:系统取消touch事件的时候触发

device-aspect-ratio，指的是输出设备的屏幕可见宽度与高度的比率。

等于或小于980px
@media screen and(max-width:980px){
    wdith:90%;
}

iPad横板显屏
等于或小于1024px的设备宽度
@media screen and (max-device-width: 1024px) and (orientation: landscape) {
    /* CSS Styles */
}
iPad竖板显屏
@media screen and (max-device-width: 768px) and (orientation: portrait) {
    /* CSS Styles */
}

orientation   porirait/landscape  横屏或竖屏
    -webkit-min-device-pixel-ratio为1.0

    所有非Retina的Mac
    所有非Retina的iOS设备
    Acer Iconia A500 
    Samsung Galaxy Tab 10.1
    Samsung Galaxy S 

 

    -webkit-min-device-pixel-ratio为1.3

    Google Nexus 7

 

    -webkit-min-device-pixel-ratio为1.5

    Google Nexus S 
    Samsung Galaxy S II 
    HTC Desire
    HTC Desire HD
    HTC Incredible S 
    HTC Velocity
    HTC Sensation 

 

    -webkit-min-device-pixel-ratio为2.0

    iPhone 4
    iPhone 4S
    iPhone 5
    iPad (3rd generation)
    iPad 4
    所有Retina displays 的MAC
    Google Galaxy Nexus
    Google Nexus 4
    Google Nexus 10
    Samsung Galaxy S III
    Samsung Galaxy Note II
    Sony Xperia S
    HTC One X 

css Hack:
用于选择IE浏览器及IE的不同版本
if条件Hack是html级别的（包含但不仅是css的Hack,可以选择任何html代码块）
<!--[if IE]>
<p>你在非IE中将看不到我的身影</p>
<![endif]-->


只有IE浏览器才能看到是红色的；
<!--[if IE]>
<style>
.test{color:red;}
</style>
<![endif]-->


只有IE6以上（包含IE6），才能看到此效果。
<!--[if gte IE 6]>
<style>
.test{color:blue;}
</style>
<![endif]-->

只有IE7以下，才能看到此效果。
<!--[if lt IE 7]>
<style>
.test{color:grey;}
</style>
<![endif]-->


小于或是等于<!--[if lte IE7]>

除了IE7以外的IE版本，都能看到此效果。
<!--[if ! IE 7]>
<style>
.test{color:green;}
</style>
<![endif]-->


1.如何清除图片下方出现几像素的空白间隙？
方法1：
img{display:block;}
方法2：
img{vertical-align:top;}
除了top值，还可以设置为text-top|middle|bottom|text-bottom,甚至特定的<length>和<percentage>值都可以
方法3：
#test{font-size:0;line-height:0;}
#test为img的父元素。
2.如何让文本垂直对齐输入框？
input{vertical-align:middle;}
3.如何让单行文本在容器内垂直居中？
#test{height:20px;line-height:20px;}
4.如何让超链接访问后和访问前的颜色不同且访问后仍保留hover和active效果？
a:link{color:#03c;}
a:visited{color:#666;}
a:hover{color:#f30;}
a:active{color:#c30}
按L-V-H-A顺序设置超链接样式。
5.为什么Standard mode下IE无法设置滚动条的颜色？
html{
    scrollbar-3dlight-color:#999;
    scrollbar-darkshadow-color:#999;
    scrollbar-highlight-color:#fff;
    scrollbar-shadow-color:#eee;
    scrollbar-arrow-color:#000;
    scrollbar-face-color:#ddd;
    scrollbar-track-color:#eee;
    scrollbar-base-color:#ddd;
}
将原来设置在body上的滚动条颜色样式定义到html标签选择符上即可。
6.如何使文本溢出边界不换行强制在一行内显示？
#test{width:150px;white-space:nowrap;}
设置容器的宽度和white-space为nowrap即可，其效果类似<nobr>标签。

7.如何使文本溢出边界显示为省略号？
此方法Firefox5.0尚不支持
#test{width:150px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;}
首先需设置文本强制在一行显示，然后将溢出的文本通过overflow:hidden截断，并以text-overflow:ellipsis方式将截断的文本显示为省略号。

8.如何使连续的长字符串自动换行？
#test{width:150px;word-wrap:break-word;}
word-wrap的break-word值允许单词内换行。
9.如何清除浮动？
(1)#test{clear:both;}
#test为浮动元素的下一下兄弟元素。
(2)#test{display:block;zoom:1;overflow:hidden;}
#test为浮动元素的父元素。zoom:1也可以替换固定的width或height。
(3)#test{zoom:1;}
    #test:after{display:block;clear:both;visibility:hidden;height:0;content:'';}
    #test为浮动元素的父元素。
10.如何定义鼠标指针的光标形状为手型并兼容所有浏览器？
#test{cursor:pointer;}
若将cursor设置为hand,将只有IE和Opera支持，且hand为非标准属性值。
11.如何让已知高度的容器在页面中水平垂直居中？
#test{position:absolute;top:50%;left:50%;width:200px;height:200px;margin:-100px 0 0 -100px}
12.如何让未知尺寸的图片在已知宽高的容器内水平垂直居中？
#test{display:table-cell;*display:block;*position:relative;widht:200px;height:200px;text-align:center;vertical-align:middle;}
#test p{*position:absolute;*top:50%;margin:0;}
#test是img的祖父节点，p是img的父节点。
13.如何设置span的宽度和高度（即如何设置内联元素的宽高）？
span{display:block;width:200px;height:200px;}
14.如何给一个元素定义多个不同的css规则？
.a{color:#f00;}
.b{background:#eee;}
<div class="a b"></div>
多个规则之间使用空格分开，并且只有class能同时使用多个规则，id不可以。

15.如何让某个元素距离窗口上右下左边各10像素？
html,body{height:100%;margin:0}
html{_padding:10px;}
#test{position:absolute;top:10px;right:10px;left:10px;bottom:10px;_position:static;_height:100%;}

16.如何去掉超链接的虚线框？
a{outline:none;}
IE7及更早浏览器由于不支持outline属性，需要通过js的blur()方法来实现，如<a onfocus="this.blur();">

18.如何容器透明，内容不透明？
(1).outer{width:200px;height:200px;background:#000;filter:alpha(opacity=20):opacity:.2;}
.inner{width:200px;height:200px;margin-top:-200px;}
<div class="outer">透明的容器</div>
<div class="inner">不透明的容器</div>
原理是容器层与内容层并级，容器层设置透明度，内容层通过负margin或者position绝对定位等方式覆盖到容器层上。
(2)
.outer{width:200px;height:200px;background:rgba(0,0,0,.2);background:#000\9;filter:alpha(opacity=20)\9;}
.outer .inner{position:relative\9;}
<div class="outer">
    <div class="inner">不透明内容</div>
</div>
高级浏览器直接使用rgba颜色值实现，IE浏览器在定义容器透明的同时，让子节点相对定位，也可达到效果。

19.为什么容器的背景色没显示出来？为什么容器无法自适应内容高度？
清除浮动，通常出现这样的情况都是由于没有清除浮动而引起的。
20.如何做1像素细边框的table?
#test{border-collapse:collapse;border:1px solid #ddd;}
#test th,#test td{border:1px solid #ddd;}
<table id="test">
    <tr><th>姓名：</th><td>Joy</td></tr>
</table>

20.为什么2个相邻div的margin只有1个生效？
.box1{margin:10px 0;}
.box2{margin:20px 0;}
<div class="box1"></div>
<div class="box2"></div>
本例中的box1的底部margin为10px,box2的顶部margin为20px,但表现在页面上2者之间的间隔为20px,而不是预想中的10px+20px=30px,结果是选择2者之间最大的那个margin,我们把这种机制称之为"外边距合并"；外边距合并不仅仅出现在相邻的元素间，父子间同样会出现。
a、外边距合并只出现在块级元素上；
b、浮动元素不会和相邻的元素产生外边距合并；
c、绝对定位元素不会和相邻的元素产生外边距合并；
d、内联块级元素间不会产生外边距合并；
e、根元素间不会产生外边距合并(如html与body间)；
f、设置了属性overflow且值不为visible的块级元素不会与它的子元素发生外边距合并；

21、如何在文本框中禁用中文输入法？
input,textarea{ime-mode:disabled;}
ime-mode为非标准属性，只有IE,Firefox支持。
22.如何解决列表中list-style-image不能精准定位的问题？
不使用list-style-image来定义列表目标记符号，而用background-image来代替，并通过background-position来进行定位。


<a href="javascript:void(0)">点击</a>点击链接后不会回到网页顶部
<a href="#">点击</a>点击后会回到网页顶部
伪类选择符：
E:link:设置超链接a在未被访问前的样式。
E:visited:设置超链接a在其链接地址已被访问时的样式。
E:hover:设置元素在其鼠标悬停时的样式。
E:active:设置元素在被用户激活（在鼠标点击与释放之间发生的事件）时的样式。
E:focus：设置元素在成为输入焦点（该元素的onfocus事件发生）时的样式。
E:lang(fr):匹配使用特殊语言的E元素。
overflow:
visible:对溢出内容不做处理，内容可能会超出容器。
hidden:隐藏溢出容器的内容且不出现滚动条。
scroll:隐藏溢出容器的内容，溢出的内容将以卷动滚动条的方式呈现。
auto:当内容没有溢出容器时不出现滚动条，当内容溢出容器时出现滚动条，按需出现滚动条。此为body对象和textarea的默认值。


em：相对于当前对象内文本的字体尺寸。
ex：相对于字符"x"的高度，通常为字体 高度的一半。
ch：数字"0"的宽度。
rem：相对于根元素（即html元素）font-size计算值的位数。


sandbox:沙盒：轻量级的隔离机制，快速重建和销毁，占用资源少。用docker在开发者的单机环境下模拟分布式软件部署和调试，可谓又快又好。

同时docker提供的版本控制和image机制以及远程image管理，可以构建类似git的分布式开发环境。可以看到用于构建多平台image的docker以及同一作者的vagrant已经在这方面有所尝试了。

Docker是一个命令行工具，它提供了中央"docker"执行过程中所需的所有工具。这使得Docker的操作非常简单。一


1024bit/s=1Kbit/s 　　1024Kbit/s=1Mbit/s 　　1024Mbit/s=1Gbit/s 
1024 bit=1k  1024 k =1m  1024 m = 1G
1 KB = 1024Bytes  1MB = 1024KB 1GB = 1024 MB 1TB = 1024 GB

百度传课：http://zt.chuanke.com/2015/it?statistics_channel_id=5&statistics_uid=13#a3

Backbone.js为复杂的Javascript应用程序提供模型(models)、集合(collections)、视图(views)的结构。其中，模型用于绑定键值数据和自定义事件，集合附有可枚函数的丰富API，视图可以声明事件处理函数，并通过RESRful JSON接口连接到应用程序。


_：选择IE6及以下。连接线（中划线）（-）亦可使用，为了避免与某些带中划线的属性混淆，所以使用下划线（_）更为合适。
*：选择IE7及以下。诸如：（+）与（#）之类的均可使用，不过业界对（*）的认知度更高
\9：选择IE6+
\0：选择IE8+和Opera15以下的浏览器



css样式表的主要作用是修饰web页面上的html标记，但有时候，为了实现某个效果而往页面里反复添加某个html标记很繁琐，或者是显得多余，或者是由于某种原因而做不到，这就是css伪元素可以发挥作用的地方，所谓"伪元素"，就是本身不存在的页面元素，html代码里并没有这样的元素，但在页面显示时，你却能看到这些本来就不存在的元素发挥着作用。
伪类和伪元素：
伪类：伪类用于向某些选择器添加特殊的效果。
伪元素：伪元素用于将特殊的效果添加到某些选择器。
span:hover伪类
span::before伪元素

伪类：:hover :link, :active, :target, :not(s), :focus, etc.
伪元素：:first-letter, :first-line, :before, :after, ::selection

常见伪类——:hover;:link;:active;:target;:not();:focus。
常见伪元素——::first-letter;::first-line;::before;::after;::selection。

::before和::ater下特有的content，用于在css渲染中向元素逻辑上的头部或尾部添加内容。
这些添加不会出现在DOM中，不会改变文档内容，不可复制，仅仅是在css渲染层加入。
所以不要用:before或:after展示有实际意义的内容，尽量使用它们显示修饰性内容，例如图标。
举例：网站有些联系电话，希望在它们前加一下icon，就可以使用:before伪元素，

:before   选择器在被选元素的内容前面插入内容。
:after   选择器在被选元素的内容后面插入内容。
使用content属性来指定要插入的内容。
content有几个比较有用的值：
[String]-使用引号包括一段字符串，将会向元素内容中添加字符串。
a:after{content:"..."}

jQuery(window).height()代表了当前可见区域的大小，而jQuery(document).height()则代表了整个文档的高度，可视具体情况使用.

注意当浏览器窗口大小改变时(如最大化或拉大窗口后) jQuery(window).height() 随之改变jQuery(document).height()是不变的。

$(document).scrollTop() 获取垂直滚动的距离 即当前滚动的地方的窗口顶端到整个页面顶端的距离

$(document).scrollLeft() 这是获取水平滚动条的距离

要获取顶端 只需要获取到scrollTop()==0的时候 就是顶端了

要获取底端 只要获取scrollTop()>=(document).height()?(window).height() 就可以知道已经滚动到底端了

height：指元素内容的高度 ，jQuery中的height()方法返回的就是这个高度。
clientHeight：内容高度+padding高度 ，jQuery中的innerHeight()方法返回的就是这个高度。
offsetHeight：内容高度+padding高度+边框宽度 ，jQuery中的outerHeight()方法返回的就是这个高度。

2009年7月工作草案(display:box;)
2011年3月工作草案(display:flexbox;)
2011年11月工作草案(display:flexbox;)
2012年3月工作草案(display:flexbox;)
2012年6月工作草案(display:flex;)
2012年9月候选推荐(display:flex;)

构造函数，是一种特殊的方法。主要用来在创建对象初始化对象，即为对象成员变量赋初始值，总与new运算符一起使用在创建对象的语句中。特别的一个类可以有多个构造函数，可根据其参数个数的不同或参数 类型的不同来区分它们即构造函数的重载。

闭包就是定义在一个函数内部的函数。
在javascript语言中，只有函数内部的子函数才能读取局部变量，反之则不行。

在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。

闭包最大的用处：一是可以读取函数内部的变量；二是让这些变量的值始终保持在内存中。

闭包，最简单的描述就是ECMAScript允许使用内部函数--即函数定义和函数表达式位于另一个函数的函数体内。而且，这些内部函数可以访问它们所在的外部函数中声明的所有局部变量、参数和声明的其他内部函数。当其中一个这样的内部函数在包含它们的外部 函数之外被调用时，就会形成闭包。也就是说，内部函数会在外部函数返回后被执行。而当这个内部函数执行时，它仍然必需访问其外部函数的局部变量、参数以及其他内部函数。这些局部变量、参数和函数声明（最初时）的值是外部函数返回时的值，但也会受到内部函数的影响。

闭包是一个比较抽象的概念，尤其对于新手来说，但闭包也是js能力提升中无法绕过的一环，几乎每次面试必问的问题，因为在回答的时候，你的答案的深度，对术语的理解以及js内部解释器的动作方式的描述，都是可以看出js实际水平的
闭包是很多语言都具备的特性，在js中，闭包主要涉及到js的几个其他的特性：作用域链，垃圾（内存）回收机制，函数嵌套等等。
在理解闭包前，最好能理解一下作用域链的含义，简单来说，作用域链就是函数在定义的时候创建的，用于寻找使用到的变量的值的一个索引，而他内部的规则是，把函数自身的本地变量放在最前面，把自身的父级函数中的变量放在其次，把再高一级函数中的变量放在更后面，以此类推直至全局对象为止，当函数中需要查询一个变量的值的时候，js解释器会去作用域链去查找，从最前面的本地变量中先找，如果没有找到对应的变量，则到下一级的链上找，一旦找到了变量，则不再继续，如果找到最后也没找到需要的变量，则解释器返回undefined。

js的内存回收机制，一般来说，一个函数在执行开始的时候,会给其中定义的变量划分内存空间保存,以备后面的语句所用,等到函数执行完毕返回了,这些变量就被认为是无用的了.对应的内存空间也就被回收了.下次再执行此函数的时候,所有的变量又回到最初的状态,重新赋值使用.但是如果这个函数内部又嵌套了另一个函数,而这个函数是有可能在外部被调用到的.并且这个内部函数又使用了外部函数的某些变量的话.这种内存回收机制就会出现问题.如果在外部函数返回后,又直接调用了内部函数,那么内部函数就无法读取到他所需要的外部函数中变量的值了.所以js解释器在遇到函数定义的时候,会自动把函数和他可能使用的变量(包括本地变量和父级和祖先级函数的变量(自由变量))一起保存起来.也就是构建一个闭包,这些变量将不会被内存回收器所回收,只有当内部的函数不可能被调用以后(例如被删除了,或者没有了指针),才会销毁这个闭包,而没有任何一个闭包引用的变量才会被下一次内存回收启动时所回收.

也就是说,有了闭包,嵌套的函数结构才可以运作,这也是符合我们的预期的.然后,闭包还有一些特性,却往往让程序员觉得很难理解.

中文：方正黑体/兰亭黑/萍方/微软雅黑， 
英文：Gotham/Releway/Arial/Helvetica 
数字：proxima nova

网站图片地址：https://box.lenovo.com/l/wJ0DPx
https://box.lenovo.com/l/q5WXho



Angular.js:


特性一：双向的数据绑定：
数据绑定可能是Angular.js最酷最实用的特性。它能够帮助你避免书写大量的初始代码从而节约开发时间。一个典型的web应用可能包含了80%的代码用来处理，查询和监听DOM。数据绑定是的代码更少，你呆以专注于你的应用。

特性二：模板
在Angular.js中，一个模板就是一个HTML文件。但是HTML的内容扩展了，包含了很多帮助你映射model到view的内容。

特性三：MVC

特性四：依赖注入(Dependency Injection,即DI)

特性五：Directives（指令）




Angular JS是一个JavaScript框架，它可通过<script>标签添加到HTML页面。
Angular JS通过指令扩展了HTML，且通过表达式绑定数据到HTML。
Angular JS是一个以JavaScript编写的库。是一个以JavaScript文件形式发布的。

$emit和$broadcast都是针对$scope而言的。
$broadcast——将事件向下传播到所有子作用域，包括自己。
$emit——将事件向上传播到所有子作用域，包括自己。

AngularJS通过作用域中的事件处理通信。$on、$emit和$broadcast得到event、data在controller之间的传递变得简单。$emit只能向parent controller传递event与data,$broadcst只能向child controller传递event......
$emit只能向parent controller传递event与data;
$broadcast只能向child controller传递event与data;
$on用于接收event与data.

建议把脚本放在<body>元素的底部。
这会提高网页加载速度，因为HTML加载不受制于脚本加载。

Angular JS通过ng-directives扩展了HTML。
ng-app指令定义一个Angular JS 应用程序。
ng-model指令把元素值（比如输入域的值）绑定到应用程序。
ng-bind指令把应用程序数据绑定到HTML视图。
ng-init指令初始化Angular JS应用程序变量。
HTML5允许扩展的（自制的）属性，以data-开关。
ng-class ng-class-odd ng-class-even
ng-style

ng-show,ng-hide当值为true时，对应的show或hide生效。
ng-checked控制radio和checkbox的选中状态。
ng-selected控制下拉框的选中状态。
ng-disabled控制失效状态。
ng-readonly控制只读状态。

使用ng-if的情况,用它代替所有的ng-show和ng-hide
原因在ng-show还是会执行其中的所有绑定,ng-if则会在等于true,也就是显示的时候再去执行其中的绑定.这样一来性能就有很大的提高

<ul>
    <li ng-repeat="person in persons">
        <span ng-switch on="person.sex">
            <span ng-switch-When="1">you are a boy</span>
            <span ng-switch-When="2">you are a girl</span>
        </span>
        <span ng-if="person.sex==1">you may be a father</span>
        <span ng-if="person.sex==2">you may be a mother</span>
        <span>please input your baby's name:<input type="text" ng-disabled="!person.hasBaby" /></span>
    </li>
</ul>

在模板中可以用变量$event将事件对象传递到controller中。

通常一个页面可能会有固定的top-menu或者sidebar,这类固定不变的部分,然后每次route变化的都是ng-view的template,如果一个页面希望整个页面完全显示它自己,不包括top-menu之类固定的部分.

这里通常是一个index.html和一个ng-view显示的template.html,top-menu和sidebar位于index.html中,将它们的显示隐藏通过ng-if绑定一个变量控制.

如果一个页面需要自己完全显示,不显示sidebar等,则在其controller中通过$scope.$emit向上发送一个消息,然后index页面的controller则通过$scope.$on监听消息,一旦听到那个消息,则改变控制sidebar显隐的变量.

也可以通过service做一个全局的变量控制,个人推荐还是通过消息广播的方式.

Angular JS是一个开发动态Web应用的框架。它让你可以使用html作为模板语言并且可以通过扩展的html语法来使应用更加清晰和简洁。它的创新之处在于，通过数据绑定和依赖注入减少了大量代码，，而这些都在浏览器端通过JavaScript实现，能够和作保服务器端技术完美结合。
Angular 是为了扩展html在构建应用时本应具备的能力而设计的。对于静态文档，html是一门很好的声明式的语言，但对于构建动态web应用，它无能为力。所以，构建动态web应用往往需要一些技巧才能让浏览器配合我们的工作。

类库：一些在开发web应用时非常有用的函数的集合。你的代码起主导作用，并且决定何时调用类库的方法，例如：jQuery等。
框架：一种web应用的特殊实现，你的代码只需要填充一些具体信息。框架起主导作用，并且决定何时调用你的代码。例如：knockout,ember等。

类库、框架、插件

原生js：即纯JavaScript，没有经过任何的封装，也就是所有前端框架类库的底层，遵循ECMAScript标准，不依赖于任何框架，依托于浏览器标准引擎的脚本语言，不利于兼容以及实现。

js类库：如大家最熟悉的jQuery。其实就是将原生js根据需要进行封装形成的一些组件方法，方便使用。

js框架：angular.js。比类库更有系统性，侧重的是一整套解决方案。

前端框架：bootstrap。一般由js库css库各种插件库组成，是写好的各种可重用的组件，主要用于网站快速开发，直接可以出一套页面。

我们再来大概的区分下类库与框架，library和framework：
当你在调用library的时候，你按照自己的意愿来control他（比如jQuery）。而对于framework，那么control就是倒转过来了，是他在调用你（比如bootstrap）。

所以，类库，解决的是代码或者是模块级别的利用或者对复杂度的封装问题，例如jQuery获取DOM节点这个复杂问题的功能模块 封装成一个函数$，提供一个简单的接口。库它是一咱工具，它提供了很多封装好的的方法，用与不用取决于我们自身，即使用了也不会影响我们的代码结构。

而框架，更多的是对模式级别的利用和对程序组织的规范。是面向一个领域来提供一套解决方案，提高开发效率，如果我们选择了使用某框架，就应该遵循该框架所规定的规则。

所以，简单地说，框架要求你用某种形式去写代码，比如遵照MVC的约定，等等。库只是提供了写代码时实现某种形式的方法，比如提供了XHR的封装，对DOM的简便操作等。

接下来说说引入一个框架可能产生的问题：
性能损失。但凡框架都会带来性能损失，这也是一些对性能要求很高的项目往往不会使用框架，而为自己的场景定制优化。当然这个性能在如今来说大概也可以忽略了。
复杂度提升。学习成本和部署成本这就是你必然要面对的问题。
适应性。框架一旦引入，你的整体结构就被固定死了，你需要按照固定的模式去使用，这个地方加一些自己写的具体代码，另外一个地方加一点，这些都是框架帮你规定好了的。这东西可能其实也挺好，方面你后续维护什么的，但是你得去适应。
摩擦。这个东西就不好说了，有些框架有些地方可能非常符合你的需求，有些地方却不是你想要的，甚至是反向的。这个时候你要么就去hack一下，要么就去修改一下该框架的源代码。总之你使用起来不会特别爽。

作者：李陈
链接：https://www.zhihu.com/question/20780639/answer/16450455
来源：知乎
著作权归作者所有，转载请联系作者获得授权。


在jquery中，你会先设计一个页面，然后让它变得动态化。这是因为jquery是为了扩展而设计的，并在这个前提下变得越来越臃肿。
但是在Angular.js中，你必须从一开始就在脑子里挂着架构的弦。不要一开始就想着“我有这样一个DOM，我想让它做.........”，你必须从你要完成的目标开始思考，然后设计你的应用，最后才是设计你的视图。

Angular另辟蹊径，它尝试去扩展HTML的结构来弥合以文档为中心的HTML与实际Web应用所需要的HTML之间的鸿沟。Angular通过指令（directive）扩展HTML的语法。例如：

    通过{{}}进行数据绑定。
    使用DOM控制结构来进行迭代或隐藏DOM片段。
    支持表单和表单验证。
    将逻辑代码关联到DOM元素上。
    将一组HTML做成可重用的组件。

一个完整的前端解决方案

在构建WEB应用的前端时，Angular提供的不是一个部分解决方案，而是一个完整的解决方案。它能够处理所有你写过的混杂了DOM和AJAX的代码，并能够将它们组织的结构良好。这使得Angular在决定应该怎样构建一个CRUD应用时显得甚至有些“偏执（opinionated）”，但是尽管它“偏执”，它也尝试确保使用它构建的应用能够灵活的适应变化。下面是Angular的一些出众之处：

    构建一个CRUD应用时可能用到的所有技术：数据绑定、基本模板指令、表单验证、路由、深度链接、组件重用、依赖注入。
    可测试性：单元测试、端到端测试、模拟对象（mocks）、测试工具。
    拥有一定目录结构和测试脚本的种子应用。

Angular的可爱之处

Angular通过给开发者呈现更高层次的抽象来简化应用的开发。和其他的抽象一样，它也以损失灵活性为代价。换句话说，Angular并不是适合任何应用的开发，Angular考虑的是构建CRUD应用。幸运的是，绝大多数WEB应用都是CRUD应用。为了理解Angular适用哪些场合，知道它不适合哪些场合是很有帮助的。

对于像游戏和有图形界面的编辑器之类的应用，会进行频繁且复杂的DOM操作，和CRUD应用不同。因此，可能不适合用Angular来构建。在这种场景下，使用更低抽象层次的类库可能会更好，例如：jQuery。


作用域是Web应用的控制器和视图之间的粘结剂，在Angrular中，最直观的表现是：在自定义指令中，处在模板的链接(linking)阶段时，指令(directive)会设置一个$watch函数监听着作用域中各表达式(这个过程是隐式的)。这个$watch允许指令在作用域中的属性变化时收到通知。进而让指令能够根据这个改变来对dom进行重新渲染，以便更新已改变的属性值（属性值就是scope对象中的属性，也就是数据模型）。

作用域是web应用的控制器和视图之间的粘结剂，在angular中，最直观的表现是：在自定义指令中，处在模板的链接阶段时，指令会设置一个$watch函数监听着作用域中各表达式。这个$watch允许指令在作用域中的属性变化时收到通知。进而让指令能够根据这个改变来对dom进行重新渲染，以便更新已改变的属性值
理解视图：
绝大多数模板引擎系统采用的是把字符串模板和数据拼接，然后输出一个新的字符串，在前端这个新的字符串作为元素的innerHTML属性的值。

angular js 动画，ngRepeat,ngSwitch,ngView,而自定义指令则可以通过$animate服务来实现。这些动画在各种指令的生命周期内触发，触发时，它会尝试执行css过渡动画(Transition),css关键帧动画(Keyfame Animation)或JavaScript回调动画(callback Animation)（取决于指令中的设定)。
angular 的编译器直接使用DOM作为模板而不是有字符串模板，编译阶段的返回结果是一个连接函数，在连接阶段会和特定的作用域中的数据模型连接生成一个实时的视图，视图和作用域模型的绑定是透明的，开发者不需要做任何特别的调用去更新视图。同时，我们不使用innerHTML属性，这样也就不会影响用户输入了，而且，angular指令不仅可以包含文本绑定，同时也支持行为操作的绑定。

http://docs.ngnice.com/guide/controller

模板(Template):带有Angular扩展标记的HTML
指令(Directive):用于通过自定义属性和元素扩展HTML的行为。
模型(Model):用于显示给用户并且与用户互动的数据。
作用域(Scope):用来存储模型(Model)的语境(context)。模型放在这个语境中才能被控制器、指令和表达式等访问到。
表达式(Expression):模板中可以通过它来访问作用域(Scope)中的变量和函数。
过滤器(Filter):负责格式化(Expression)的值，以便呈现给用户。
视图(View):用户看到的内容(即DOM)。
数据绑定(Data Binding):自动同步模型(Model)中的数据和视图(View)表现。
控制器(Controller):视图(View)背后的业务逻辑。
依赖注入(Dependency Injection):负责创建和自动装载对象或函数。
注入器(Indector):用来实现依赖注入(Injection)的容器。
模块(Module):用来配置注入器。
服务(Service)：独立于视图(View)的、可复用的业务逻辑。

指令：
简单点说，指令就是一些附加在html元素上的自定义的标记（例如：属性，元素，或css类），它告诉Angular js 的html编译器($compile)在元素上附加某些指定的行为，甚至操作DOM.改变DOM元素，以及它的各级子节点。
简单点说，指令就是一些附加在html元素上的自定义的标记
当创建一个含有自己模板的组件的时候，建议使用元素名，觉情况是，当你想为你的模板创建一个DSL（特定领域语言）的时候，如果仅仅想为已有的元素添加功能，建议使用属性名。

compile和link选项是AngularJS中需要深入讨论的高级话题之一，对于了解AngularJS究竟是如何工作的至关重要。
compile选项本身并不会被频繁使用，但是link函数则会被经常使用。本质上，当我们设置了link选项，实际上是创建了一个postLink()链接函数，以便compile()函数可以定义链接函数。
通常情况下，如果设置了compile函数，说明我们希望在指令和实时数据被放到DOM中之前进行DOM操作，在这个函数中进行诸如添加和删除节点等DOM操作是安全的。
compile和link选项是互斥的。如果同时设置了这两个选项，那么会把compile所返回的函数当作链接函数，而link选项本身则会被忽略。


执行一个清理的工作。当指令被移除时，用
element.on('$destroy',....)或scope.$on('$destroy',...)

scope是angularJS中的作用域(其实就是存储数据的地方)，很类似javascript的原型链 。搜索的时候，优先找自己的scope，如果没有找到就沿着作用域链向上搜索，直至到达根作用域rootScope。
$rootScope是由angularJS加载模块的时候自动创建的，每个模块只会有1个rootScope。rootScope创建好会以服务的形式加入到 $injector中。也就是说通过 $injector.get("$ rootScope ");能够获取到某个模块的根作用域。更准确的来说，$rootScope是由angularJS的核心模块ng创建的。
scope是html和单个controller之间的桥梁，数据绑定就靠他了。rootscope是各个controller中scope的桥梁。用rootscope定义的值，可以在各个controller中使用

input
http://v2.bootcss.com/base-css.html#forms
http://ui-grid.info/docs/#/tutorial/204_column_resizing
https://fortawesome.github.io/Font-Awesome/icons/
http://ui-grid.info/docs/#/api/ui.grid.class:GridOptions.columnDef
http://ui-grid.info/docs/#/api/ui.grid.class:GridOptions.columnDef
http://bootswatch.com/
http://ui-grid.info/docs/#/api/index
https://angular-ui.github.io/bootstrap/#/modal
https://docs.angularjs.org/api/ng/directive/input
http://www.hubwiz.com/course/
https://fortawesome.github.io/Font-Awesome/icons/
http://bootswatch.com/
bootswatch是一款基于bootstrap的汇集了多种风格的前端UI解决方案
图表
http://api.highcharts.com/highcharts#Chart
document.querySelector("div.test>p:first-child");

Angular 提供了有关表单的属性来帮助我们验证表单. 他们给我们提供了各种有关一个表单及其输入的信息，并且应用到了表单和输入.
属性类     
    描述
$valid  ng-valid    Boolean 告诉我们这一项当前基于你设定的规则是否验证通过
$invalid    ng-invalid  Boolean 告诉我们这一项当前基于你设定的规则是否验证未通过
$pristine   ng-pristine     Boolean 如果表单或者输入框没有使用则为True
$dirty  ng-dirty    Boolean 如果表单或者输入框有使用到则为True



JSONLint
1xx信息类，表示收到web浏览器请求，正在进一步的处理中
2xx成功200ok
3xx重定向，表示请求没有成功，客户必须采取进一步的动作
4xx客户端错误 ，表示客户端提交的请求有错误，例如：404not
found 意味着请求中所引用的文档不存在
5xx服务器错误，表示服务器不能完成对请求的处理，如500

导航：nav; 主导航：mainnav; 子导航：subnav
菜单：menu; 子菜单：submenu; 侧栏：sidebar

css样式表文件命名：
主要的：master.css
模块：module.css
基本共用的：base.css
布局、版面：layout.css
主题：themes.css
专栏：columns.css
文字：font.css
表单：forms.css
补丁：mend.css
打印：print.css

1、了解决npm，spm，node.js吗？请简要描述？
NPM便于javascript开发者共享和重用代码，它可以很容易地更新你的代码；再分享。是全球最大的开源生态系统。
SPM是淘宝社区电商业务(xTao)为外部合作伙伴(外站)提供的一套跟踪引导成交效果数据的解决方案。
Node.js是一个基于Chrome V8引擎的JavaScript运行环境。node.js使用了一个事件驱动，非阻塞式I/O的模型，使其轻量又高效。它使我们能够在本地运行javascript。

2、服务器Node.js和浏览器js的区别是什么？
Node.js把js从客户端迁移到了服务器、主要做了哪些工作？为什么说Node.js适合做高并发的互联网应用？
Node采用一系列“非阻塞”库来支持事件循环的方式。本质上就是为文件系统、数据库之类的资源提供接口。Node.js使用事件驱动，非阻塞I/O模型而得以轻量和高效，非常适合在分布设备上运行数据密集型的实时应用。

3、什么叫代码部署？如何部署？
代码部署就是把开发好的网站代码放到应用服务器上对外提供服务、部署方式根据编程语言的不同而不同，但是大体的流程是一致的，生产环境主要是通过命令加配置文件的形式进行部署。
4、前端到底工作内容是什么？和UI有什么区别？
前端：主要讲UI提供的设计图，编码成静态html，实现所有特效，并负责所有交互的对接，对js要求较高；
UI：主要对移动端和网页的设计

4、CDN是啥？
CDN的全称：是Content DeliveryNetwork，即内容分发网络，加速的意思，那么网站CDN服务就是网站加速服务。
CDN加速原理：CDN加速将网站的内容缓存在网络边缘（离用户接入网络最近的地方），然后在用户访问网站内容的时候，通过调度系统将用户的请求路由或者引导到离用户接入网络最近或者访问效果最佳的缓存服务器上，有该缓存服务器为用户提供内容服务；相对于直接访问源站，这种方式缩短了用户和内容之间的网络距离，从而达到加速的效果。
a、本地加速：提高了企业站点（尤其含有大量图片和静态页面站点）的访问速度，并大大提高以上性质站点的稳定性。
b、镜像服务：消除了不同运营商之间互联的瓶颈造成的影响，实现了跨运营商的网络加速，保证不同网络中的用户都能得到良好的访问质量。
c、远程加速：远程访问用户根据DNS负载均衡技术，智能自动选择Cache服务器，选择最快的Cache服务器，加快远程访问的速度。
d、带宽优化：自动后成服务器的远程Mirror(镜像)cache服务器，远程用户访问时从cache服务器上读取数据，减少远程访问的带度、分担网络流量、减轻原站点WFB服务器负载等功能。
e、集群抗攻击：广泛分布的CDN节点加上节点之间的智能冗于机制，可以有效地预防黑客入侵以及降低各咱D.D.o.S攻击对网络的影响，同时保证较好的服务质量。

5、浏览器一次可以从一个域名下请求多少资源？
浏览器的并发请求数目限制是针对同一域名的，同一时间针对同一域名下的请求有一定数量限制，不同浏览器这个限制的数目不一样，超过限制数目的请求会被阻塞；
目前的话，所有浏览器的并发数目一般限制在10以内。
6、个么是垃圾回收机制（GC）？
早期的计算机语言，比如C和C++，需要开发者手动的来跟踪内存，这种机制的优点是内存分配和释放的效率很高。但是它也有着它的缺点，程序员很容易不小心忘记释放内存，从而造成内存的泄露。
新的编程语言，比如java,C#,javascript,都提供了所谓“垃圾回收的机制”，运行时自身会运行相应的垃圾回收机制。程序员只需要申请内存，而不需要关注内存的释放。垃圾回收器（GC）会在适当的时候将已经终止生命周期的变量的内存给释放掉。GC的优点就在于它大简化了应用层开发的复杂度，降低了内存泄露的风险。

7、image和canvas在处理图片的时候有什么区别？
image是通过对象的形式描述图片的。
canvas是通过专门的API将图片绘制在画布上的。

8、响应式布局的时候，轮播图使用两张不同的图片去适配大屏幕和超小屏幕，还是一张图片进行压缩适配不同终端，说明原因？
最好使用两张不同大小的图片来适配大屏幕和超小屏幕，这样可以针对不同设备的屏幕大小，来加载响应的图片，减少超小屏幕设备的网络流量消耗，加快响应速度，同时防止图片在大屏幕下分辨率不够导致失真的问题。

9、HTTP和TCP有什么区别？
TPC/IP协议是传输层协议，主要解决数据如何在网络中传输，是一种“经过三次握手”的可靠的传输方式；
HTTP协议即超文本传送协议（Hypertext Transfer Protoclo），是应用层协议，是Web联网的基础，也是手机联网常用的协议之一，HTTP协议是建立在TCP协议之上的一种应用。

10、设计模式有哪些？列举你在前端开发工作中自己应用到或者了解到其他框架所用到的设计模式？
单例、工厂、观察者、适配器、代理模式

1、工作中用过什么构建工具？
用过gulp。
第一步：安装node和npm，搭建node环境。
第二步：安装gulp
第三步：新建Gulpfile文件，运行gulp
安装依赖，提醒下，如果以上命令提示权限错误，需要添加sudo再次尝试。
Gruntfile维护起来那么困难，有几个原因：
配置和运行分离，
程序员都知道，变量的声明和使用挨在一起，最方便理解和修改。但Gruntfile里，配置Task和调用它们的地方离得很远，极大地增加了心智负担。
每个插件做的事太多
每个Task的结果必须写到磁盘文件，另一个Task再读，损害性能倒是小事，更麻烦的是让整个过程变复杂了。就像一个个小作坊，来料加工又返回给客户，这中间的沟通成本 ，出错机会都大大增加。配置项过多做事多了，配置项自然也多。至少输入和输出的位置得配吧。每个插件的配置规则还不尽相同。用每个插件，都得去学习一番。

2、请谈谈你对性能优化的认识？
网页内容：减少http请求次数，80%的响应时间花在下载网页内容(images,stylesheets,javascripts,scripts,flash等）。减少请求次数是缩短响应时间的关键！可以通过简化页面设计来减少请求次数，但页面内容较多可以采用以下技巧。
a、减少DNS查询次数
b、缓存Ajax
Ajax可以帮助我们异步的下载网页内容，但是有些网页内容即使是异步的，用户还是在等待它的返回结果，例如ajax的返回是用户联系人的下拉列表。所以我们还是要注意尽量应用以下规则提高ajax的响应速度。
延迟加载，
javascript是典型的可以延迟加载的内容。一个比较激进的做法是开发网页时先确保网页在没有javascript的时候也可以基本工作，然后通过延迟加载脚本来完成一些高级的功能。

3、谈谈你对模块化的理解？
a、模块化就是为了减少系统耦合度，提高高内聚，减少资源循环依赖，增强系统框架设计。
b、让开发都便于维护，同时也让逻辑相同的部分可利用。
c、模块化开发：针对js、css、以功能或业务为单元组织代码。js方面解决独立作用域、依赖管理、api暴露、按需加载与执行、安全合并等问题，css方面解决依赖管理、组件内部样式管理等问题。
4、模块化的过程就是：
a、拆分：
将整个系统按功能，格式，加载顺序，继承关系分割为一个一个单独的部分。
注意：拆分的粒度问题，可复用问题，效率问题，如果这些问题处理得不好，就会有可能出现不想要的后果。
将功能或特征相似的部分合在一起，组成一个资源块。
将每个资源块按找需求，功能场景以及目录约束放到固定的地方以供调用。
5、模块化的发展也是从草根一步一步走过来的。从最开始到现在成熟方案：
a、namespace
b、sass,less
c、AMD&CMD
d、grunt,gulp,webpack
e、FLS,YUI,KISSY
6、请描述一下cookie，sessionStorage和localStroage的区别？
cookies兼容所有的浏览器，HTML5提供的storage存储方式。
Document.cookie
Window.localstorage
Window.sessionstorage

